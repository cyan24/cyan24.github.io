<!DOCTYPE html>
<!--[if IE 6]>
<html id="ie6" lang="zh-CN">
<![endif]-->
<!--[if IE 7]>
<html id="ie7" lang="zh-CN">
<![endif]-->
<!--[if IE 8]>
<html id="ie8" lang="zh-CN">
<![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8)  ]><!-->
<html lang="zh-CN" class="js">
<!--<![endif]-->
  

	

	
<head>
	<meta charset="utf-8">
	<title>前端开发 | Cyan的技术笔记</title>
	<meta name="description" content="Cyan的技术笔记">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-Frame-Options" content="sameorigin">
	<!-- CSS -->
	<link rel="stylesheet" href="/css/main.css">
	<link rel='stylesheet' id='divi-style-css'  href="/css/style.css" type='text/css' media='all' />
	<link rel="stylesheet" href="/css/post.style.css">

	<script type='text/javascript' src="/js/jquery.js"></script>
	<script type='text/javascript' src="/js/soundmanager2-nodebug-jsmin.js"></script>

	<!--Favicon-->
	<link rel="icon" href="favicon.ico" type="image/x-icon"/>
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
	
	<link href="/favicon.ico" mce_href="favicon.ico" rel="bookmark" type="image/x-icon" /> 
	<link href="/favicon.ico" mce_href="favicon.ico" rel="icon" type="image/x-icon" /> 
	<link href="/favicon.ico" mce_href="favicon.ico" rel="shortcut icon" type="image/x-icon" /> 
	<!-- Canonical -->
	<link rel="canonical" href="http://localhost:4000/front/">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="Cyan的技术笔记" href="http://localhost:4000/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.js"></script>
	

	<!-- Google Analytics -->
	

	<script type="text/javascript">
    var host = "cyan24.com";
    if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location.protocol = "https";
    </script>
    
</head>

	<body class="home blog et_pb_button_helper_class home-posts et_fixed_nav et_show_nav et_cover_background et_pb_gutter windows et_pb_gutters3 et_primary_nav_dropdown_animation_fade et_secondary_nav_dropdown_animation_fade et_pb_footer_columns4 et_header_style_left et_right_sidebar chrome">
		<div id="page-container">
    		<header id="main-header" data-height-onload="66">
	<div class="container clearfix et_menu_container">
		<div class="logo_container">
			<span class="logo_helper"></span>
			<a href="/">
				<!--img src="http://blog.ibireme.com/wp-content/uploads/2015/05/logo1.png" alt="Garan no dou" id="logo" data-height-percentage="54" /-->
				Cyan的技术笔记
			</a>
		</div>
		<div id="et-top-navigation" data-height="66" data-fixed-height="40">
			<nav id="top-menu-nav">
				<ul id="top-menu" class="nav">
					<li>
						<a class="page-link" href="/">
							首页
						</a>
					</li>
					
					
					
					
					<li>
						<a class="page-link" href="/About/">
							关于我
						</a>
					</li>
					
					
					
					<li>
						<a class="page-link" href="/Archives/">
							所有文章
						</a>
					</li>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					<li>
						<a class="page-link" href="/front/">
							前端开发
						</a>
					</li>
					
					
					
					
					
					
					
					<li>
						<a class="page-link" href="/server/">
							后端开发
						</a>
					</li>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					<!-- Social icons from Font Awesome, if enabled -->
					<li>
						<a class="page-link" href="">Find Me</a>
						<ul class="children">












<li>
	<a href="https://github.com/cyan24" title="Follow on GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>





























<li>
	<a href="mailto:chinazjcy@aliyun.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>
</ul>
					</li>
					
				</ul>
			</nav>

			<div id="et_mobile_nav_menu">
				<div class="mobile_nav closed">
					<span class="select_page"></span>
					<span class="mobile_menu_bar"></span>
				</div>
			</div>				
		</div> <!-- #et-top-navigation -->
	</div> <!-- .container -->
	<div class="et_search_outer">
		<div class="container et_search_form_container">
			<form role="search" method="get" class="et-search-form" action="http://localhost:4000">
			<input type="search" class="et-search-field" placeholder="搜索 &hellip;" value="" name="s" title="搜索：" /></form>
			<span class="et_close_search_field"></span>
		</div>
	</div>
</header> <!-- #main-header -->

    		<div id="et-main-area">
      			<div class="home">
  <article class="feature-image" >
  	<div style="background-image: url('/img/sample_feature_img.png')"/>
  	<header style="background-image: url('https://source.unsplash.com/category/nature/2600x500')">
    <h1 class="call-out-title">前端开发</h1>
    </header>
  </article>

<div class="posts">
    
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/2016%E4%B8%8A%E6%B5%B7-iWeb-%E5%B3%B0%E4%BC%9A%E5%B0%8F%E8%AE%B0/">
		        2016上海 iWeb 峰会小记
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2016年06月7日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle"></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>早前在公众号看到会议的日程，果断报名参加了这次峰会。想对下午工具应用场的几个印象比较深刻多分享做一下小记。</p>

<p><img src="/img/post/1606071.jpg" alt="" /></p>

<p>Hax 的 《ES6+代码风格和质量标准》
Intel 的 《VR &amp; Realsense in Crosswalk》
勾股 的 《Weex 跨平台渲染实现》</p>

<p>###ES6+代码风格和质量标准###</p>

<p><img src="/img/post/1606072.jpg" alt="" />
<img src="/img/post/1606073.jpg" alt="" /></p>

<p>Hax 贺老还是一如既往喜欢用风趣来带入代码『哲学』问题。在人人都开始逐渐迈入 ES6 的时代，通过控制一个团队级别的代码风格规范，会更容易控制代码的质量。其中特意介绍了 ESLint，Eslint具有高度可配置、预置大量规则、可共享复用(git搜索 eslint-config)等等优势。大概的规则分为：可能是错误，最佳实践，变量声明等等，贺老的建议是能用的规则都用上。。。
事后有小伙伴专门用ESLint跑了一下代码，用贺老推荐的airbnb的代码规范，据说错误刷爆了，如下这种情况会报错：</p>

<pre><code class="language-js">
oneList.forEach(function(item) {
    // doSomething
});

</code></pre>

<p>这样的代码会报 Missing function expression name 的警告。改成如下可以消除这个警告。</p>

<pre><code class="language-js">
oneList.forEach(function each(item) {
    // doSomething
});

</code></pre>

<p>目前还不了解airbnb这样写的目的。如果有小伙伴知道请m我。。</p>

<table>
  <tbody>
    <tr>
      <td>而ES6+的总体原则是尽量用Es6的语法，比如：ajax =&gt; promise,Class工厂 =&gt; 原生 Class 语法，arguments =&gt; …args，</td>
      <td> </td>
      <td>=&gt; 函数默认参数，回调函数 =&gt; 剪头函数等等。</td>
    </tr>
  </tbody>
</table>

<p>然后贺老还调侃了space党和tab党之间的偏见，算是一个轻松的话题引入，主要是分享了一个他写Atom插件: elastic-tabstops。同时推荐下Atom编辑器。</p>

<p>就目前看来，代码规范这件事，还是要根据不同的情况：业务&amp;框架、 ES5&amp;ES6+、Brower&amp;Node等不同场景来制定。</p>

<p>附上演讲用的原版资料：http://johnhax.net/2015/es6-code-style/#0</p>

<hr />

<p>###VR &amp; Realsense in Crosswalk###</p>

<p><img src="/img/post/1606074.jpg" alt="" /></p>

<p>都说今年是vr元年，之前就一直在想，前端离vr的距离是多远，这次分享就有了答案，前端能搞 VR？答案是 Yes！这次的 iWeb 峰会中，前端 VR 技术让我真正认识到 JS 真的没有什么不能做的。因特尔通过vr主推了他们的开源项目Crosswalk。Crosswalk 可以简单理解为增强版的 webkit，用于 Hybird 项目中，可替代原生的浏览器。对于前端vr场景而言，强悍的浏览器是支持vr的必不可少的一部分，
Crosswalk优势是多平台支持，对 WEBGL支持，对 VR，RealSense支持，知名应用比如有道云接入，谷歌的Mobile Chrome App团队接入，对兼容性的把握，对性能的优秀的处理等等。</p>

<p>Crosswalk有三种接入模式：
嵌入模式，和native打包到一起，作为 HTML5页面的 webview 使用；
共享模式：不用打包到单个App中，系统只需要一个 crosswalk供所有应用去调用；
还有一种下载模式：好像是应用需要依赖 crosswalk，然后貌似自动会去 app store下载。</p>

<p>最后我觉得想在业务中推广使用的硬伤还是体积问题，完整包大概20M左右，轻
量版也有10M，为了引入 crosswalk 安装包多10M，产品会噘嘴吧。。
当天早前在他们展位现场体验了webVR小游戏，效果狠酷炫，感受很真实，演讲中还讲到一项技术web for RealSense，用手隔空操作小车的移动。</p>

<p>这次因特尔的vr分享使更多前端开发者有了一个新的方向和期待，未来出了平面化的web 前端开发，vr说不定会成为一个前端再次闪耀的新热点。</p>

<hr />

<p>###Weex 跨平台渲染实现###</p>

<p><img src="/img/post/1606075.jpg" alt="图片" /></p>

<p>Week 作为阿里近期主推的一款跨平台移动开发工具，这次会场中据说一半以上听众是冲着他来的。2015年双11，Weex 成功突围，算是成为阿里最好的跨平台工具，再从 QConf 宣布内测 和 iWeb 的分享 到 6 月份的正式开源，Weex 为更多人所认知，毕竟是大厂出品，又经过了双11的考验，可靠程度还是值得信任的。当天weex分享主要由勾股领衔，主要做了大概的产品介绍，Demo展示，如何调试，还有一些技术实现细节。Weex目前还是私有项目也只有Android部分，可以在<a href="http://alibaba.github.io/weex/">官网</a>通过git帐号申请获取权限，计划在6月份完全开源。</p>

<p>weex和react-native 是同类型的框架，但 weex 主打的是轻量，语法简单，上手容易。weex借鉴了 vue，而 vue 和 react 相比学习成本还是比较低的。</p>

<p>Weex 和 React Native 的一大区别是模板的构建形式：</p>

<p>React Naitve 的 UI 和业务逻辑一般是在一起的，这比较符合 Native 的开发习惯。 Weex 采用了前端常用的方式，模板和逻辑分离，而模板采用 vuejs、hogan、avalon、artTemplate 等等模板使用的  双大括号的形式，使前端工程师开发起来非常顺手。同时，Native 工程师学习使用 Weex ，成本将会提高。
最后，笔者感觉 Weex 是针对前端开发人员设计的一款工具框架，比较适合前端同学使用；而 React Native 是基于前端语言构建的一个 Native 框架，前端开发者会有一定的学习使用成本的同时（Native 的开发思想等），Native 开发者也会有一定的学习使用成本（ES6 语法等）。当然，环境搭建是共有的成本。</p>

<p>weex框架也再次肯定了用js开发原生的这种模式，作为前端开发人员还是需要去多关注下。此外，vue社区今年应该会更活跃，关注度更高。</p>


		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/js%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/">
		        js中继承的几种方式总结
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2016年05月4日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/javascript/">Javascript</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>总结一下js中继承的几种方式，主要从 apply,call,prototype 展开。</p>

<p>###js中对象继承###</p>

<p>js中有三种继承方式：</p>

<p><strong><em>1.js原型（prototype）实现继承</em></strong></p>

<pre><code class="language-html">
    function Person(name,age){  
        this.name=name;  
        this.age=age;  
    }  
    Person.prototype.sayHello=function(){  
        console.log("使用原型得到Name："+this.name);  
    }  
    var per=new Person("cyan",21);  
    per.sayHello(); //输出：使用原型得到Name:cyan 

      
    function Student(){}  
    Student.prototype=new Person("cyan24",21);  
    var stu=new Student();  
    Student.prototype.grade=5;  
    Student.prototype.intr=function(){  
        console.log(this.grade);  
    }  
    stu.sayHello();//输出：使用原型得到Name:cyan24 
    stu.intr();//输出：5  


</code></pre>

<hr />

<p><strong><em>2.构造函数实现继承</em></strong></p>

<pre><code class="language-html">
    function Parent(name){  
        this.name=name;  
        this.sayParent=function(){  
            console.log("Parent:"+this.name);  
        }  
    }  

    function Child(name,age){  
        this.tempMethod=Parent;  
        this.tempMethod(name);  
        this.age=age;  
        this.sayChild=function(){  
            console.log("Child:"+this.name+"age:"+this.age);  
        }  
    }  

    var parent=new Parent("cctest");  
    parent.sayParent(); //输出：“Parent:cctest”  
    var child=new Child("Jack",24); //输出：“Child:Jack age:24”  
    child.sayChild();  


</code></pre>
<hr />

<p><strong><em>3.call , apply实现继承</em></strong></p>

<pre><code class="language-html">

    function  Person(name,age,love){  
        this.name=name;  
        this.age=age;  
        this.love=love;  
        this.say=function say(){  
            alert("姓名："+name);  
        }  
    }  

    //call方式  
    function student(name,age){  
        Person.call(this,name,age);  
    }  

    //apply方式  
    function teacher(name,love){  
        Person.apply(this,[name,love]);  
        //Person.apply(this,arguments); //跟上句一样的效果，arguments  
    }  

    //call与aplly的异同：  
    //1,第一个参数this都一样,指当前对象  
    //2,第二个参数不一样：call的是一个个的参数列表；apply的是一个数组（arguments也可以）  

    var per=new Person("Andy",25,"Mike"); //输出：“Andy”  
    per.say();  
    var stu=new student("曲筱绡",18);//输出：“曲筱绡”  
    stu.say();  
    var tea=new teacher("关关",16);//输出：“关关”  
    tea.say();  


</code></pre>

<hr />

<p>###call和apply的用法（详细介绍）###</p>

<p>js中call和apply都可以实现继承，唯一的一点参数不同，func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])。</p>

<p>JS手册中对call的解释：</p>

<p>call 方法调用一个对象的一个方法，以另一个对象替换当前对象。</p>

<p>call([thisObj[,arg1[, arg2[,   [,.argN]]]]])</p>

<p>参数 thisObj :可选项。将被用作当前对象的对象。</p>

<p>arg1, arg2,  , argN  :可选项。将被传递方法参数序列。</p>

<p><strong>说明 :</strong></p>

<p>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</p>

<p>如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</p>

<p>说简单一点，这两函数的作用其实就是更改对象的内部指针，即改变对象的this指向的内容。这在面向对象的js编程过程中有时是很有用的。下面以apply为例，说说这两个函数在 js中的重要作用。如：</p>

<pre><code class="language-html">
function Person(name,age){   //定义一个类   
    this.name=name;     //名字   
    this.age=age;       //年龄   
    this.sayhello=function(){alert(this.name)};  
}  
function Print(){            //显示类的属性   
    this.funcName="Print";  
    this.show=function(){  
        var msg=[];  
        for(var key in this){  
            if(typeof(this[key])!="function"){  
                msg.push([key,":",this[key]].join(""));  
            }  
        }  
        alert(msg.join(" "));  
    };  
}  
function Student(name,age,grade,school){    //学生类   
    Person.apply(this,arguments);//比call优越的地方   
    Print.apply(this,arguments);  
    this.grade=grade;                //年级   
    this.school=school;                 //学校   
}  

var p1=new Person("扎克伯格",80);  
p1.sayhello();  
var s1=new Student("白云飞",40,9,"浙江大学");  
s1.show();  
s1.sayhello();  
alert(s1.funcName);
 
</code></pre>

<hr />

<p>另外，<strong>在提升程序性能方面</strong> Function.apply()有着明显的作用：
我们先从Math.max()函数说起，Math.max后面可以接任意个参数，最后返回所有参数中的最大值。
比如:</p>

<pre><code>alert(Math.max(5,8));   //8   
alert(Math.max(5,7,9,3,1,6));   //9   

//但是在很多情况下，我们需要找出数组中最大的元素。   

var arr=[5,7,9,1];  
//alert(Math.max(arr));    // 这样却是不行的。NaN   

//要这样写   
function getMax(arr){  
    var arrLen=arr.length;  
    for(var i=0,ret=arr[0];i&lt;arrLen;i++){  
        ret=Math.max(ret,arr[i]);  
    }  
    return ret;  
}  

alert(getMax(arr)); //9   

//换用apply，可以这样写   
function getMax2(arr){  
    return Math.max.apply(null,arr);  
}  

alert(getMax2(arr)); //9   

//两段代码达到了同样的目的，但是getMax2却优雅，高效，简洁得多。   

//再比如数组的push方法。   
var arr1=[1,3,4];  
var arr2=[3,4,5];  
//如果我们要把 arr2展开，然后一个一个追加到arr1中去，最后让arr1=[1,3,4,3,4,5]   
//arr1.push(arr2)显然是不行的。 因为这样做会得到[1,3,4,[3,4,5]]   

//我们只能用一个循环去一个一个的push(当然也可以用arr1.concat(arr2)，但是concat方法并不改变arr1本身)   

var arrLen=arr2.length;  
for(var i=0;i&lt;arrLen;i++){  
    arr1.push(arr2[i]);  
}  

//自从有了Apply,事情就变得如此简单   

Array.prototype.push.apply(arr1,arr2); //现在arr1就是想要的结果
</code></pre>


		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/web%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84requestAnimationFrame/">
		        web动画中的requestAnimationFrame
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2016年04月5日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/动画/">动画</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>在HTML5/CSS3普遍应用的今天，在web里做动画选择其实已经很多了:</p> <p>CSS3的animattion+keyframes;</p> <p>css3的transition;</p> <p>或者是canvas上作图来实现动画，也可以借助jQuery动画相关的API方便地实现;</p> <p>当然最原始的你还可以使用window.setTimout()或者window.setInterval()通过不断更新元素的状态位置等来实现动画，前提是画面的更新频率要达到每秒60次也就是16.7ms ,才能让肉眼看到流畅的动画效果。</p> <p>以上方法几乎可以完成平时的百分之九十的需求，那requestAnimationFrame还有什么存在的价值呢～～？ 先来一步步认识一下他吧！</p> <hr /> <p>###requestAnimationFrame是什么###</p> <p>我们先看看<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">MND</a>上怎么说明的：</p> <blockquote> <p><em>The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes as an argument a callback to be invoked before the repaint.</em> <em>window.requestAnimationFrame() 将告知浏览器你马上要开始动画效果了，后者需要在下次动画前调用相应方法来更新画面。这个方法就是传递给window.requestAnimationFrame()的回调函数。</em></p> </blockquote> <p>其实就是和我们熟悉的setTimeout/setInterval差不多，通过递归调用同一方法来不断更新画面以达到动起来的效果，但它优于setTimeout/setInterval的地方在于它是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。</p> <hr /> <p>###我们怎么用###</p> <p>可以直接调用，也可以通过window来调用，接收一个函数作为回调，返回一个ID值，通过把这个ID值传给window.cancelAnimationFrame()可以取消该次动画。</p> <pre><code class="language-js"> requestAnimationFrame(callback)//callback为回调函数 </code></pre> <hr /> <p>###一个煎蛋的栗子###</p> <p>模拟一个进度条动画，初始div宽度为1px,在step函数中将进度加1然后再更新到div宽度上，在进度达到100之前，一直重复这一过程。</p> <pre><code class="language-html">&lt;div id="test" style="width:1px;height:17px;background:#0f0;"&gt;0%&lt;/div&gt; &lt;input type="button" value="Run" id="run"/&gt; </code></pre> <pre><code class="language-js">window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; var start = null; var ele = document.getElementById("test"); var progress = 0; function step(timestamp) { progress += 1; ele.style.width = progress + "%"; ele.innerHTML=progress + "%"; if (progress &lt; 100) { requestAnimationFrame(step); } } requestAnimationFrame(step); document.getElementById("run").addEventListener("click", function() { ele.style.width = "1px"; progress = 0; requestAnimationFrame(step); }, false); </code></pre> <hr /> <p>###兼容情况### 来看看它的<a href="http://caniuse.com/#search=requestAnimationFrame">兼容</a>情况：</p> <p><img src="/img/post/1604051.png" alt="" /></p> <hr /> <p>###备胎这件事###</p> <p>是的你没有看错，我们要插播一下Polyfill ，也就是相当于兼容方案中的备胎。</p> <p>Polyfill也有称作垫片，按发明这个词的人的原话来说，它就是一段这样的代码，让浏览器原生地支持我们期望使用的一些API。</p> <p>就比如这里的requestAnimationFrame，在看到了上面的浏览器支持情况后，你就知道了比上面列出的浏览器版本老的就不支持该方法，但为了让代码能够有更好的浏览器兼容性在老机器上也能运行不报错，我们可以写一些代码让浏览器在不支持requestAnimationFrame的情况下使用window.setTimeout()，这是一种回退（fallback）到过去的方法。</p> <p>这样一来，就可以通俗一点的理解polyfill了，它就是备胎。</p> <p>下面是由Paul Irish及其他贡献者放在GitHub Gist上的代码片段，用于在浏览器不支持requestAnimationFrame情况下的备胎方案，回退到使用setTmeout的情况。当然，如果你确定代码是工作在较新大浏览器中，下面的代码是不必的。</p> <pre><code class="language-js">// http://paulirish.com/2011/requestanimationframe-for-smart-animating/ // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel // MIT license (function() { var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) { window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame']; } if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) { var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16.7 - (currTime - lastTime)); var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall); lastTime = currTime + timeToCall; return id; }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) { clearTimeout(id); }; }()); </code></pre> <p>上面代码作用有二，一是把各浏览器前缀进行统一，二是在浏览器没有requestAnimationFrame方法时将其指向setTimeout方法。</p> <p>提到备胎代码呢，这里多说一句，在CSS代码中，我们也经常使用这种回退的技巧，即对同一条CSS规则，编写多条以不同浏览器前缀开头代码，或者编写一条备用样式。</p> <p>下面是一个CSS中的备胎代码的栗子：</p> <pre><code class="language-css">div { background: rgb(0, 0, 0); /* fallback */ background: rgba(0, 0, 0, 0.5); } </code></pre> <p>代码中设置div背景为黑色带50%的透明度，但IE9-的浏览器是不支持rbga格式的颜色的，所以浏览器会回退到上一条CSS规则应用rgb颜色。</p> <hr /> <p><strong>一些补充</strong></p> <p>根据<a href="https://segmentfault.com/a/1190000000386368">这篇翻译文章</a>一些测试说法，FireFox/Chrome浏览器对setInterval, setTimeout做了优化，页面处于闲置状态的时候，如果定时间隔小于1秒钟(1000ms)，则停止了定时器。与requestAnimationFrame有类似行为。但如果时间间隔大于或等于1000ms，定时器依然执行，即使页面最小化或非激活状态。</p> <p><img src="/img/post/1604052.png"...
		    <p>
		    <a class="text" href="/blog/web%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84requestAnimationFrame/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E7%94%A8chrome%E5%AE%9E%E6%97%B6%E8%B0%83%E8%AF%95less%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%87%E4%BB%B6%E5%89%AF%E6%9C%AC-2/">
		        用chrome实时调试less编译的文件
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2016年03月23日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/less/">less</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>首先看下chrome调试时，如何实时保存到本地文件。使用chrom调试工具中的 source 进入项目目录结构，右键选择本地文件目录add floder to workspace ,添加本地文件夹，之后选择本地文件右键map to network resource。
这样就能映射本地文件直接指向服务文件，也就是在chrome中直接调试样式后，ctrl+S 后直接同步保存到了本地文件。
接下来我们要使用chorm实时调试less文件，首先要安装一个监听文件 wr,类似grunt的watch,选择wr是因为他的速度相对其他监听软件快！先执行：</p>

<pre><code class="language-html">
npm install -g wr 

</code></pre>

<p>全局安装wr,之后开始我们可以实时监听到lessc 编译某一个less的命令：</p>

<p>比如：在less文件目录执行：</p>

<pre><code class="language-html">
wr ‘less duang.less duang.css’ duang.less

</code></pre>

<p>可以监听到当我们改变duang.less时，然后保存，可以看到duang.css同时做了自动编译后的改变。</p>

<p><img src="/img/post/1602231.jpg" alt="" /></p>

<p>那怎么实时去改变chrom里的css从而改变到less呢～？
现在我们要做的就是怎么把css和less做一个映射，我们用：</p>

<pre><code class="language-html">
lessc —source-map duang.less duang.css
</code></pre>

<p>去做一个资源映射。</p>

<p><img src="/img/post/1602232.jpg" alt="" /></p>

<p>同级目录马上生成一个map文件：</p>

<p><img src="/img/post/1602233.jpg" alt="" /></p>

<p>在css文件底部，可以看到一个映射关系的说明：</p>

<p><img src="/img/post/1602234.jpg" alt="" /></p>

<p>开启浏览器映射功能：</p>

<p><img src="/img/post/1602235.jpg" alt="" />
<img src="/img/post/1602236.jpg" alt="" /></p>

<p>然后执行命令：</p>

<pre><code class="language-html">
wr 'lessc --source-map duang.less duang.css' duang.less

</code></pre>

<p><img src="/img/post/1602237.jpg" alt="" /></p>

<p>此时修改chrome中的less文件，保存刷新浏览器，同步可以修改本地的less 和css了。</p>

<p><img src="/img/post/1602238.jpg" alt="" /></p>

<p>标题修改为红色：</p>

<p><img src="/img/post/1602239.jpg" alt="" /></p>

<p>本地css和less都已自动修改：</p>

<p><img src="/img/post/16022310.jpg" alt="" /></p>

<p><img src="/img/post/16022311.jpg" alt="" /></p>

<p>以上说的这种方式在chrome调试工具的elements - Styles 下暂时没有办法做实时调试，着也是比较遗憾的一点。</p>


		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E5%85%B3%E4%BA%8Ecss3-%E5%8A%A8%E7%94%BB%E7%9A%84%E4%B8%80%E7%82%B9%E7%AC%94%E8%AE%B0/">
		        关于css3 动画的一点笔记
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2016年03月21日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/动画/">动画</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>代码中当要使用transform 和 opicity 比如同时0.3秒过渡时，下面这种写法不推荐，因为all会引起性能问题。</p>

<pre><code class="language-css">
div {
     transform :translate (0 ,-20px);
     transition: all 0.3s ease;
}
</code></pre>

<p>推荐使用下面这种写法：</p>

<pre><code class="language-css">
div {
     transform :translate (0 ,-20px);
     transition: opacity 0.3s ease,transform 0.3s ease;
}

</code></pre>

<p>另外，在兼容各种webkit 的写法时，可以使用autoprefixer 插件，在less编译成css时再编译一次，可以高效得把各种前缀都自动加了。</p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/D2%E5%89%8D%E7%AB%AF%E8%AE%BA%E5%9D%9B%E5%88%86%E4%BA%AB%E4%B9%8B%E9%98%BF%E9%87%8C%E7%AF%87/">
		        D2前端论坛分享——阿里篇
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2016年01月10日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/nodejs/">nodejs</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>前段时间回顾了一下d2论坛上阿里的分享环节，由sima分享的关于天猫的node改造历程。
首先看对比改造和未改造，性能方面的提升。在改造后使用了nodejs的页面和未改造的页面使用的时php，在2014双十一RT 和 QPS对比：</p>

<p><img src="/img/post/1511031.jpg" alt="" /></p>

<p>由上图看出，node 的RT 和 QPS 性能数据较php有大幅度优势。</p>

<p>从页面渲染的本质来看，可以从三个维度来看：</p>

<p>1.前端开发编写维护的模版；</p>

<p>2.运营维护或者后端系统产出的数据；</p>

<p>3.通过一个渲染容器进行合并产出页面。</p>

<p>示例如下：</p>

<p><img src="/img/post/1601101.jpg" alt="" /></p>

<p>通过扩展上下文，可以使前端写出简单的逻辑判断。</p>

<p><img src="/img/post/1601102.jpg" alt="" /></p>

<p>关于模版中的静态资源管理，他们是这么处理的：</p>

<p>1.前后端使用统一的资源加载器；</p>

<p>2.基于统一的seed控制依赖以及版本；</p>

<p>3.输出combo url到页面；</p>

<p>4.依赖自动去重，css/js头尾加载。</p>

<p><img src="/img/post/1601103.jpg" alt="" /></p>

<p>渲染出来后的页面：</p>

<p><img src="/img/post/1601104.jpg" alt="" /></p>

<p>另外，也做了大量点模块化工作。通过模块化，前端写的90个模块被运营组合扩展成700个页面：</p>

<p><img src="/img/post/1601105.jpg" alt="" /></p>

<p><img src="/img/post/1601106.jpg" alt="" /></p>

<p>搭建出来大概是这样的：</p>

<p><img src="/img/post/1601107.jpg" alt="" /></p>

<p>阿里从模块化到规模化大概要经历这三个过程：</p>

<ul>
  <li>跨业务共享模块；</li>
  <li>面向运营的可视化页面搭建平台；</li>
  <li>Native 页面搭建。</li>
</ul>

<p>###如何用NODE架构起服务###</p>

<p>他们的服务并没有使用express,而是使用了koa,在渲染页面方面使用了扩展的xtemplate模版，通过阿里云oss提供模板和数据的存储支持，而cdn使用了阿里的的cdn缓存支持。</p>

<p>作为koa的github维护者之一，本次分享中，sima对koa的讲解占了一定的篇幅.</p>

<p>koa不仅仅作为generator，相比于express的作为中间件顺序执行的特点，他是包裹在后面所有中间件的装饰器。</p>

<p><img src="/img/post/1601109.jpg" alt="" /></p>

<p><img src="/img/post/1601108.jpg" alt="" /></p>

<p><strong>测试覆盖率和集成测试</strong></p>

<p>让测试覆盖率告诉你bug在哪儿</p>

<p><img src="/img/post/16011010.jpg" alt="" /></p>

<p>一般很难覆盖的地方都是比较容易出bug的地方.</p>

<p>持续集成察觉每次代码变更引入的风险。</p>

<p><img src="/img/post/16011011.jpg" alt="" /></p>

<p><strong>关于Cluster</strong></p>

<ul>
  <li>
    <p>Master 只做进程管理;</p>
  </li>
  <li>
    <p>worker 异常退出后自动重启（cfork）;</p>
  </li>
  <li>
    <p>http 服务优雅退出（graceful)。</p>
  </li>
</ul>

<p>对关键指标做了监控，而异常对信息，做了警告处理。
所以一定要有日志记录。</p>

<p><strong>关于日志</strong></p>

<p>做了以下处理：</p>

<ul>
  <li>
    <p>所有的请求都有accesslog追踪；</p>
  </li>
  <li>
    <p>所有异常统一记录，并分类输出；</p>
  </li>
  <li>
    <p>依赖系统调用tracelog,记录请求和响应情况。</p>
  </li>
</ul>

<p>基于这些监控，可以获得到警告信息（如果有的话）。</p>

<p><strong>关于警告</strong></p>

<p>在以下情况作了警告的处理：</p>

<p>系统/服务状态异常的情况下如RT增高/Load增高情、依赖异常如调用失败/调用超时、服务异常如出现日常日志的情况。对于异常日志信息通过短信或者邮件反应。</p>

<p>这样就可以通过警告快速感知错误信息，通过日志和监控快速定位问题，目的是快速恢复服务。但是sima也提醒，最好是通过完善的单元测试去避免这些线上故障。</p>

<p><strong>双十一==DDOS</strong></p>

<p>每次双十一，对于阿里来说无疑都是一次类似ddos攻击，阿里的应对策略是合理利用CDN,在未改造之前需要使用几百台实体机做渲染，而改造完后用几十台虚拟机久完成了响应的活儿。</p>

<p><img src="/img/post/16011012.jpg" alt="" /></p>

<p>为了保证在CDN情况下能保证一些业务逻辑能正常运行，比如基于CDN的URL统一，比如输入www.tmall.com, 在手机上看到的和pc上看到的页面一定是不一样的，而对cdn来说却是同一份缓存内容，所以需要处理成不同终端请求同一个url时，cdn能识别设备型号，渲染服务返回不同的页面。处理方式是在cdn安装了插件来做识别.</p>

<p><strong>容灾和预案</strong></p>

<p>给出的建议是消灭单点，做异地双机房部属，oss双节点主备容灾，数据模板磁盘文件容灾。也做了预案自动化，cdn会在机房间不停得做回源健康检查，如果有异常能在10s内自动切换到健康的机房。oss健康检查，异常自动切换主备。系统load过高，自动切换静态备份。渲染异常自动切换静态备份。</p>


		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%A1%88/">
		        移动端开发用户体验提升的几个方案
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年11月14日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>H5在移动端的运用中由于种种原因，用户体验一直无法媲美原生开发的使用体验，最近对AC前端大会上腾讯前端组的分享做一个总结。</p>

<p>下面有几点方式可以尽可能的使用户体验接近原生的体验。</p>

<p><strong>使用点击态</strong></p>

<p>点击态能够给用户明确的点击反馈，提升用户体验。</p>

<ul>
  <li>方案1:使用active伪类，其缺点是滚动的时候也会触发样式。</li>
</ul>

<p>我们一般使用以下方案：</p>

<ul>
  <li>方案2:</li>
</ul>

<pre><code class="language-js">
$el.on('tap',function(e){
   var $target = $(e.target);
   $target.addClass('active');
   
   setTimeout(function(){
      $target.removeClass('active');
   },150)

})
</code></pre>
<p><strong>关于页面滚动</strong></p>

<p>先看一个页面滚动的定义：
页面滚动可以分为局部滚动和全局滚动。全局滚动是指滚动条在body节点或者更顶层。局部滚动是指滚动条在body下的某个dom节点上。</p>

<p>在ios上 默认支持全局滚动，对于局部滚动，默认没有滚动条，且滑动起来干涩。</p>

<p>在ios局部滚动用以下代码实现弹性滚动效果。</p>

<p><img src="/img/post/1511141.png" alt="" /></p>

<p>建议：将属性挂在body上，可以避免很多奇怪的bug.</p>

<p>在安卓方面，因为定制版本比较多，表现各异。默认没有弹性滚动效果。
以下效果默认浏览器不支持，安卓版的chrome下支持。
<img src="/img/post/1511142.png" alt="" /></p>

<p>在ios下如使用局部滚动，解决方案是：
使用scrollFix:</p>

<pre><code class="language-js">if(startTopScroll &lt;=0)
   elem.scrollTop = 1;

if(startTopScroll + elem.offsetHeight &gt;= elem.scrollHeight)
   elem.scrollTop = elem.scrollHeight - elem.offsetHeight - 1 ;
   
</code></pre>

<p><img src="/img/post/1511147.png" alt="" /></p>

<p><strong>局部滚动长列表的优化</strong></p>

<p>方案1:使用div局部滚动</p>

<p><img src="/img/post/15111418.png" alt="" /></p>

<p>方案2:div原生滚动连动内容层</p>

<p>折中的方案：分离滚动层与内容层，滚动的加速减速仍由滚动层div局部滚动控制，通过监听div的scroll事件，联动内容层：
<img src="/img/post/15111419.png" alt="" /></p>

<p>这种方案在小米手机上出现了严重的问题，滚动时，内容直接从起始位置瞬间跳到了终点位置。虽然div 的scroll事件可以触发，但是scroll过程中产生的样式变更，却要等到滚动结束后才能渲染。
资料中对旧版ios的描述，与小米手机相似：</p>

<p><img src="/img/post/15111420.png" alt="" /> 
<img src="/img/post/15111421.png" alt="" /> 
___</p>

<p><strong>关于键盘定制</strong></p>

<p>在英文输入法下，输入首字母如果要取消自动首字母大写，可以使用autocapitalize = ‘off’ 这个属性：</p>

<p><img src="/img/post/1511144.png" alt="" /></p>

<p>关于键盘定制的行为和样式，在ios下基本支持，在安卓下不同系统不同定制版本支持情况不同。</p>

<p><strong>移动web首屏时间概念</strong></p>

<p>移动web首屏优化实践：</p>

<p><img src="/img/post/1511148.png" alt="" /></p>

<p>通过网络阶段后在服务端渲染时，以webp为例，过程如下：</p>

<p><img src="/img/post/15111410.png" alt="" /></p>

<p>从可优化幅度到角度看，网络层面的优化比渲染方面的优化带来的红利更多。</p>

<p><img src="/img/post/1511149.png" alt="" /></p>

<p><img src="/img/post/15111411.png" alt="" /></p>

<p>这里我们要关注一个概念，也就是RTT,RTT是指一个回路时间。</p>

<p><img src="/img/post/15111412.png" alt="" /></p>

<p><img src="/img/post/15111413.png" alt="" /></p>

<p><strong>网络耗时的测定</strong></p>

<ul>
  <li>
    <p>html5提供了网络测速方法；</p>
  </li>
  <li>
    <p>Navigation Timing:获得主页相关性能数据；</p>
  </li>
  <li>
    <p>Resource Timing:获得主页相关资源的性能数据（iframe,image,script,audio,vedio…）;</p>
  </li>
</ul>

<p>我们的最终目标是：</p>

<ul>
  <li>
    <p>减小请求数；</p>
  </li>
  <li>
    <p>减小传输提及；</p>
  </li>
  <li>
    <p>尽可能得利用缓存；</p>
  </li>
  <li>
    <p>缩短关键路径；</p>
  </li>
  <li>
    <p>合理安排请求顺序。</p>
  </li>
</ul>

<p>具体方案：</p>

<p>1.DNS 预解析</p>

<p><img src="/img/post/15111414.png" alt="" /></p>

<p>2.域名收敛</p>

<p><img src="/img/post/15111415.png" alt="" /></p>

<p>3.链路复用</p>

<p><img src="/img/post/15111416.png" alt="" /></p>


		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AFa%E6%A0%87%E7%AD%BEhref%E7%82%B9%E5%87%BB%E8%B7%B3%E8%BD%AC%E5%88%B0%E4%B8%8B%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%90%8C%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84-a-href-%E7%A9%BF%E9%80%8F%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E8%A7%A3%E5%86%B3/">
		        移动端a标签href点击跳转到下一个页面同位置上的< a href>穿透点击事件解决
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年10月22日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/html5/">html5</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>项目中遇到的一个问题。移动开发的h5页面上(部分安卓机型)，点击前一个页面的a标签，进入下一个页面后，此时下一个页面的相同位置上也有一个a标签，此时会将后一个页面中的a标签点击触发。</p>

<p><strong><em>解决方案：</em></strong></p>

<p>将原来的&lt; a&gt;标签改为 div ，用移动端的 ontouchstart 事件代替，此时前一个页面点击事件不会穿透到下一个页面同位置的点击区域。</p>

<pre><code class="language-javascript">
$(function () {
         var div = document.getElementById("operate_tbkp");
         //touchstart类似mousedown
         //div.ontouchstart = function(e){
         div.ontouchstart = function(e){
         //事件的touches属性是一个数组，其中一个元素代表同一时刻的一个触控点，从而可以通过touches获取多点触控的每个触控点
         //由于我们只有一点触控，所以直接指向[0]
         //var touch = e.touches[0];
         //获取当前触控点的坐标，等同于MouseEvent事件的clientX/clientY
         //var x = touch.clientX;
         //var y = touch.clientY;
         window.location.href='../applicationformAppcs/formBilling';
         };
 })

</code></pre>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/H5%E5%BC%80%E5%8F%91%E4%B8%AD%E5%9B%9B%E7%A7%8D%E9%A1%B5%E9%9D%A2%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E6%A8%A1%E5%BC%8F/">
		        H5开发中四种页面横向滑动模式
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年09月20日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/html5/">html5</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>近年来移动网络速率的提升以及设备硬件水平的不断提高，webapp朝着更趋向于native化的水平发展，其表现效果和性能也会越来越好，现在来看未来很有可能替代native或者平起平坐，那么我们研究更好的交互体验是非常有必要的。</p> <p>目前我们所常见的webapp越来越多的是以SPA(single page application)的模式进行开发，同时嵌套在android或者ios本地壳里面，也就是hybrid应用，这种开发方式所带来的优势就不多讨论，本文研究的重点是在SPA模式中，页面间横向滑动切换场景时模式是怎样设计的，将展示并阐述四种横向滑动模式的架构布局及CSS设计方案，供大家参考。</p> <p>一、容器整体滑动（DEMO只演示A-B-C-B，下同） 模拟动画效果见下图(上)，滑动分解见下图(下)：</p> <p><img src="/img/post/1509201.gif" alt="" /></p> <p><img src="/img/post/1509202.jpg" alt="" /></p> <p><a href="http://nirvana.sinaapp.com/demo_slider/slider_1.html">demo</a></p> <p>布局方式：父容器相对定位并撑满整个device的viewport，子页面绝对定位并依次并排排列在viewport中（从左到右）</p> <pre><code class="language-css">.view-container { // 父容器布局方式 position: relative; width: 100%; height: 100%; padding-top: 44px; box-sizing: border-box; -webkit-transform: translate3d(0,0,0); //激活GPU 3D加速 -webkit-backface-visibility: hidden; } .page-container { // 子页面布局方式 position: absolute; z-index: 1; top: 0; left: 0; // 初始化为0，动态计算第N个page，并赋值(N-1)*100% width: 100%; height: 100%; overflow: hidden; background-color: #F8F8F8; } </code></pre> <p>滑动方式：父容器利用CSS3的动画transform3D进行X轴的滑动(JS控制直接喷到DOM节点中) ___</p> <p>二、单个页面滑动 模拟动画效果，见下图：</p> <p><img src="/img/post/1509202.gif" alt="" /></p> <p><img src="/img/post/1509203.jpg" alt="" /></p> <p><a href="http://nirvana.sinaapp.com/demo_slider/slider_2.html">demo</a></p> <p>布局方式：父容器高度100%，子容器正常文档流布局（X轴隐藏，Y轴默认原生滚动）</p> <pre><code class="language-css">.view-container { height: 100%; } .page-container { position: relative; width: 100%; min-height: 100%; overflow-x: hidden; background-color: #F8F8F8; } </code></pre> <p>滑动方式：利用class添加动画样式（keyframes animation），左右进出各一种</p> <pre><code class="language-css"> @-webkit-keyframes sliderightout{from{-webkit-transform:translateX(0px);opacity:1}to{-webkit-transform:translateX(50%);opacity:0}} @-webkit-keyframes slideleftin{from{-webkit-transform:translateX(-50%);opacity:0}to{-webkit-transform:translateX(0px);opacity:1}} @-webkit-keyframes slideleftout{from{-webkit-transform:translateX(0px);opacity:1}to{-webkit-transform:translateX(-50%);opacity:0}} @-webkit-keyframes sliderightin{from{-webkit-transform:translateX(50%);opacity:0}to{-webkit-transform:translateX(0px);opacity:1}} .slideleftout{-webkit-animation:slideleftout 350ms ease-in-out;} .slideleftin{-webkit-animation:slideleftin 350ms ease-in-out;} .sliderightout{-webkit-animation:sliderightout 350ms ease-in-out;} .sliderightin{-webkit-animation:sliderightin 350ms ease-in-out;} .animatestart{position:absolute;top:0;left:0;z-index:3;width:100%;height:100%;overflow-x:hidden} .animatestart.page-container{overflow-x:hidden;-webkit-transform:translate3d(0,0,0);-webkit-backface-visibility:hidden;background-color:#f5f5f5} </code></pre> <hr /> <p>三、双页联动滑动 模拟动画效果，见下图：</p> <p><img src="/img/post/1509203.gif" alt="" /></p> <p><img src="/img/post/1509204.jpg" alt="" /></p> <p><a href="http://nirvana.sinaapp.com/demo_slider/slider_3.html">demo</a></p> <p>布局方式：类似于第一种，父容器和子容器都绝对定位于viewport中，不同点是父类的上级布局更加细分，且大胆使用了webkit-box弹性盒子；子容器没有并排显示，而是重叠隐藏</p> <pre><code class="language-css">.view-container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; } .page-container { position: absolute; z-index: 1; top: 0; left: 0; bottom: 0; right: 0; width: 100%; height: 100%; overflow: hidden; background-color: #F8F8F8; -webkit-transform:translate3d(0,0,0); -webkit-backface-visibility:hidden; } </code></pre> <p>滑动方式：滑动开始时先将隐藏的下一个子页面拉到viewport右侧与当前子页面平行，然后紧接着两个子页面同步滑动，最后回归样式，中间的时间差事件均有JS控制（详见demo逻辑）</p> <hr /> <p>四、三舞台双页视差滑动 模拟动画效果见下图（上），分解逻辑图见下图（下）：</p> <p><img src="/img/post/1509204.gif" alt="" /></p> <p><img src="/img/post/1509205.jpg" alt="" /></p> <p><a href="http://nirvana.sinaapp.com/demo_slider/slider_4.html">demo</a></p> <p>布局方式：这里我设定了三舞台(stage)的概念，其实就是当前viewport的左右侧各虚拟一个同样大小的viewport，当然，正常情况下我们只能看到当前舞台的子页面，leftstage是-100%的位置，rightstage是100%的位置，我们分别用三个class来定义：pageOld、pageInit、pageNew来代替</p> <p>.pageInt { -webkit-transform: translateX(0); transform: translateX(0); } .pageOld { -webkit-transform: translateX(-100%); transform: translateX(-100%); } .pageNew { -webkit-transform: translateX(100%); transform: translateX(100%); } } 滑动方式： 1，定义正向（向左滑）和反向（向右滑）两个概念,； 2，定义快速和慢速两个概念； 则就是四种动态两种组合：正向快速+正向慢速、反向快速+反向慢速；</p> <pre><code class="language-css">.slideSlow { -webkit-transition: -webkit-transform 400ms cubic-bezier(0.42, 0, 0.58, 1.0) 0.1s; -ms-transition: transform 400ms cubic-bezier(0.42, 0, 0.58, 1.0) 0.1s; } .slideFast { -webkit-transition: -webkit-transform 300ms cubic-bezier(0.42, 0, 0.58, 1.0); -ms-transition: transform 300ms cubic-bezier(0.42, 0, 0.58, 1.0); } .slideSlowBack { -webkit-transition: -webkit-transform 400ms cubic-bezier(0.42, 0, 0.58, 1.0); -ms-transition: transform 400ms cubic-bezier(0.42, 0, 0.58, 1.0); } .slideFastBack { -webkit-transition: -webkit-transform 300ms cubic-bezier(0.42, 0, 0.58, 1.0) 0.1s; -ms-transition: transform 300ms cubic-bezier(0.42, 0, 0.58, 1.0) 0.1s; } </code></pre> <p>其中在三舞台视差滑动中的滑动曲线是经过数次的真机实验后找到的参数（cubic-bezier(0.42, 0, 0.58, 1.0)），这条曲线的滑动形态最接近IOS...
		    <p>
		    <a class="text" href="/blog/H5%E5%BC%80%E5%8F%91%E4%B8%AD%E5%9B%9B%E7%A7%8D%E9%A1%B5%E9%9D%A2%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E6%A8%A1%E5%BC%8F/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87tab%E5%9C%86%E8%A7%92%E5%9B%BE%E7%89%87-%E5%87%BA%E7%8E%B0%E9%98%B4%E5%BD%B1%E8%A7%A3%E7%9A%84bug/">
		        移动设备tab圆角图片，出现阴影解的bug
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年09月18日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/html5/">html5</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>做好的页面在手机端测试时，发现部分浏览器，tap后会出现一个半透明的灰色背景，发现是tap后的背景高亮，要重设这个表现，则需要设置-webkit-tap-highlight-color为所需色彩，直接透明吧：</p>

<pre><code class="language-css">a,img,button,input,textarea{-webkit-tap-highlight-color:rgba(255,255,255,0);}
</code></pre>

<p>另外，如何去掉textarea,input的默认样式（IOS上的圆角及内阴影等，Android未测试）：</p>

<pre><code class="language-css">input,textarea{-webkit-appearance:none;}
</code></pre>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/.jpg-.png%E8%BD%AC%E6%8D%A2%E6%88%90.webp/">
		        .jpg、.png转换成.webp
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年07月18日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>一、什么是Webp WebP是Google新推出的影像技术，它可让网页图档有效进行压缩，同时在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%，进而让整体网页下载速度加快。为了改善JPEG的图片压缩技术，他们使用了一种基于VP8编码(已在2010五月开源)的图片压缩器，利用预测编码技术，同时还采用了一种基于RIFF的非常轻量级的容器。这种容器只会给每张图片增加20字节，但能让图片作者保存他们想要存储的元数据。 与JPEG相同，WebP是一种有损压缩利用预测编码技术。</p> <p>二、Webp文件制作准备</p> <p>Google开发并放出了不同操作系统的WebP文件解码器(libvpx)和命令行工具(webpconv)。 下载地址： <a href="http://code.google.com/intl/zh-CN/speed/webp/download.html">http://code.google.com/intl/zh-CN/speed/webp/download.html</a></p> <p>我下载了用于Windows的WebpCodecSetup.exe 和libwebp-0.1.3-windows-x86.zip</p> <ol> <li>先安装WebpCodecSetup.exe，</li> <li>解压libwebp-0.1.3-windows-x86.zip（无需安装）</li> </ol> <p>三、Jpg或png转换到Webp方法</p> <p>进入libwebp-0.1.3-windows-x86.zip的解压目录，可以看到cwebp.exe和dwebp.exe，其中cwebp.exe是将jpg或png文件转换成webp文件，dwebp.exe是将webp文件转换成png、pp或pgm。这两个程序只能在dos命令行环境下运行</p> <ol> <li> <p>点击“开始”-&gt;“运行”-&gt;输入 cmd 后回车进入dos环境</p> </li> <li> <p>输入路径进入解压文件夹，以下是我安装的路径</p> </li> </ol> <p>C:\Documents andSettings\Administrator&gt;e: E:&gt;cd libwebp-0.1.3-windows-x86 E:\libwebp-0.1.3-windows-x86&gt;</p> <ol> <li>输入命令，将jpg或png转换成webp</li> </ol> <p>命令行结构：cwebp [-preset &lt;…&gt;] [options] in_file [-o out_file]</p> <p>E:\libwebp-0.1.3-windows-x86&gt; cwebp -qquality e:\photo\png1.png -o e:\webp1.webp （回车） （e:\photo\png1.png是原文件路径，e:\webp1.webp是目标文件路径）</p> <p>Saving file ‘ webp1.webp’</p> <p>27672 bytes Y-U-V-All-PSNR 30.30 32.22 32.78 30.91 dB</p> <p>block count: intra4: 1372</p> <p>intra16: 10378 (-&gt; 88.32%)</p> <p>skipped block: 6204 (52.80%)</p> <p>bytes used: header: 131 (0.5%)</p> <p>mode-partition: 13138 (47.5%)</p> <table> <tbody> <tr> <td>Residuals bytes</td> <td>segment 1</td> <td>segment 2</td> <td>segment 3</td> <td>segment4</td> <td>total</td> </tr> </tbody> </table> <table> <tbody> <tr> <td>intra4-coeffs:</td> <td>3918</td> <td>911</td> <td>268</td> <td>65</td> <td>5162 (18.7%)</td> </tr> </tbody> </table> <table> <tbody> <tr> <td>intra16-coeffs:</td> <td>3086</td> <td>1964</td> <td>881</td> <td>240</td> <td>6171 (22.3%)</td> </tr> </tbody> </table> <table> <tbody> <tr> <td>chroma coeffs:</td> <td>1627</td> <td>902</td> <td>408</td> <td>105</td> <td>3042 (11.0%)</td> </tr> </tbody> </table> <table> <tbody> <tr> <td>macroblocks:</td> <td>27%</td> <td>33%</td> <td>26%</td> <td>12%</td> <td>11750</td> </tr> </tbody> </table> <table> <tbody> <tr> <td>quantizer:</td> <td>127</td> <td>127</td> <td>127</td> <td>127</td> </tr> </tbody> </table> <table> <tbody> <tr> <td>filter level:</td> <td>19</td> <td>14</td> <td>11</td> <td>9</td> </tr> </tbody> </table> <p>——————————————————————————————————————</p> <table> <tbody> <tr> <td>segments total:</td> <td>8631</td> <td>3777</td> <td>1557</td> <td>410</td> <td>14375 (51.9%)</td> </tr> </tbody> </table> <ol> <li> <p>转换成功，在E:\libwebp-0.1.3-windows-x86目录中会生成一个webp1.webp文件</p> </li> <li> <p>cwebp通过不同命令的选项，可以对图片的大小、尺寸打印信息等进行设置。 E:\libwebp-0.1.3-windows-x86&gt;cwebp.exe –H（回车） options:</p> </li> </ol> <p>-h / -help ………… short help</p> <p>-H / -longhelp …….. long help</p> <p>-q …………. qualityfactor (0:small..100:big)</p> <p>-preset ……. Presetsetting, one of:</p> <p>default, photo, picture,</p> <p>drawing, icon, text</p> <p>-preset must come first, as it overwritesother parameters.</p> <p>-m …………… compressionmethod (0=fast, 6=slowest)</p> <p>-segments …….. number ofsegments to use (1..4)</p> <p>-s ……… Inputsize (width x height) for YUV</p> <p>-sns …………. SpatialNoise Shaping (0:off, 100:max)</p> <p>-f …………… filterstrength (0=off..100)</p> <p>-sharpness ……. filtersharpness (0:most .. 7:least sharp)</p> <p>-strong ……………. use strong filterinstead of simple.</p> <p>-partition_limit . limitquality to fit the 512k limit on the first partition (0=no degradation …100=full)</p> <p>-pass ………… analysispass number (1..10)</p> <p>-partitions …… number...
		    <p>
		    <a class="text" href="/blog/.jpg-.png%E8%BD%AC%E6%8D%A2%E6%88%90.webp/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-3/">
		        移动端上前端开发的一些问题与总结（3）
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年05月19日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/html5/">html5</a>, <a href="/tags/移动开发/">移动开发</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>###关于ios系统中，webapp启动图片在不同设备上的适应性设置</p>

<p><a href="http://stackoverflow.com/questions/4687698/mulitple-apple-touch-startup-image-resolutions-for-ios-web-app-esp-for-ipad/10011893#10011893">不同设备上的适应性设置</a></p>

<p>###关于ios系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格</p>

<p>可以通过正则去掉</p>

<pre><code class="language-js">this.value = this.value.replace(/\u2006/g, '');
</code></pre>

<p>###Cache开启和设置</p>

<pre><code class="language-js">browser.getSettings().setAppCacheEnabled(true);
browser.getSettings().setAppCachePath("/data/data/[com.packagename]/cache");
browser.getSettings().setAppCacheMaxSize(5*1024*1024); // 5MB
</code></pre>

<p>###LocalStorage相关设置</p>

<pre><code class="language-java">browser.getSettings().setDatabaseEnabled(true);
browser.getSettings().setDomStorageEnabled(true);
String databasePath = browser.getContext().getDir("databases", Context.MODE_PRIVATE).getPath();
browser.getSettings().setDatabasePath(databasePath);//Android　webview的LocalStorage有个问题，关闭APP或者重启后，就清楚了，所以需要browser.getSettings().setDatabase相关的操作，把LocalStoarge存到DB中

myWebView.setWebChromeClient(new WebChromeClient(){
　　　@Override
　　　public void onExceededDatabaseQuota(String url, String databaseIdentifier, long currentQuota, long estimatedSize, long totalUsedQuota, WebStorage.QuotaUpdater quotaUpdater){
　　　　　　　quotaUpdater.updateQuota(estimatedSize * 2);
　　　}
}
</code></pre>

<p>###浏览器自带缩放按钮取消显示</p>

<pre><code class="language-js">browser.getSettings().setBuiltInZoomControls(false);
</code></pre>

<p>###几个比较好的实践</p>

<p>使用localstorage缓存html</p>

<p>使用lazyload，还要记得lazyload占位图虽然小，但是最好能提前加载到缓存</p>

<p>延时加载执行js</p>

<p>主要原因就在于Android Webview的onPageFinished事件，Android端一般是用这个事件来标识页面加载完成并显示的，也就是说在此之前，会一直loading，但是Android的OnPageFinished事件会在Javascript脚本执行完成之后才会触发。如果在页面中使用JQuery，会在处理完DOM对象，执行完$(document).ready(function() {});事件自会后才会渲染并显示页面。</p>

<p>###移动浏览器篇</p>

<ul>
  <li>UC浏览器 video标签脱离文档流</li>
</ul>

<p>场景：标签的父元素(祖辈元素)设置transform样式后，标签会脱离文档流。</p>

<p>测试环境：UC浏览器 8.7/8.6 + Android 2.3/4.0 。</p>

<p>Demo：<a href="http://maplejan.sinaapp.com/demo/uc_fixed.html">http://t.cn/zj3xiyu</a></p>

<p>解决方案：不使用transform属性。translate用 top、 margin等属性替代。</p>

<ul>
  <li>UC浏览器 video标签总在最前场景：<video> 标签总是在最前（可以理解为video标签的z-index属性是Max）。</video></li>
</ul>

<p>测试环境：UC浏览器 8.7/8.6 + Android 2.3/4.0 。</p>

<ul>
  <li>UC浏览器position:fixed 属性在UC浏览器的奇葩现象</li>
</ul>

<p>场景：设置了position: fixed 的元素会遮挡z-index值更高的同辈元素。</p>

<p>在8.6的版本,这个情况直接出现。</p>

<p>在8.7之后的版本,当同辈元素的height大于713这个「神奇」的数值时,才会被遮挡。</p>

<p>测试环境：UC浏览器 8.8_beta/8.7/8.6 + Android 2.3/4.0 。</p>

<p>Demo：<a href="http://maplejan.sinaapp.com/demo/uc_fixed.html">http://t.cn/zYLTSg6</a></p>

<ul>
  <li>QQ手机浏览器不支持HttpOnly</li>
</ul>

<p>场景：带有HttpOnly属性的Cookie，在QQ手机浏览器版本从4.0开始失效。JavaScript可以直接读取设置了HttpOnly的Cookie值。</p>

<p>测试环境：QQ手机浏览器 4.0/4.1/4.2 + Android 4.0 。</p>

<ul>
  <li>(MIUI原生浏览器)浏览器地址栏hash不改变</li>
</ul>

<p>场景：location.hash 被赋值后，地址栏的地址不会改变。</p>

<p>但实际上 location.href 已经更新了，通过JavaScript可以顺利获取到更新后的地址。</p>

<p>虽然不影响正常访问，但用户无法将访问过程中改变hash后的地址存为书签。</p>

<p>测试环境：MIUI 4.0</p>

<ul>
  <li>(Chrome Mobile )fixed元素无法点击</li>
</ul>

<p>场景：父元素设置position: fixed;</p>

<p>子元素设置position: absolute;</p>

<p>此时，如果父元素/子元素还设置了overflow: hidden 则出现“父元素遮挡该子元素“的bug。</p>

<p>视觉(view)层并没有出现遮挡，只是无法触发绑定在该子元素上的事件。可理解为：「看到点不到」。</p>

<p>补充： 页面往下滚动，触发position: fixed;的特性时，才会出现这个bug，在最顶不会出现。</p>

<p>测试平台： 小米1S，Android4.0的Chrome18</p>

<p>demo： <a href="http://maplejan.sinaapp.com/demo/fixed_chromemobile.html">http://maplejan.sinaapp.com/demo/fixed_chromemobile.html</a></p>

<p>解决办法： 把父元素和子元素的overflow: hidden去掉。</p>

<p>以上来源于 http://www.cnblogs.com/maplejan/archive/2013/04/26/3045928.html</p>

<ul>
  <li>(微信浏览器)</li>
</ul>

<p>因为微信浏览器屏蔽了一部分链接图片，所以需要引导用户去打开新页面，可以用以下方式判断微信浏览器的ua</p>

<pre><code class="language-js">
function is_weixn(){
    var ua = navigator.userAgent.toLowerCase();
    if(ua.match(/MicroMessenger/i)=="micromessenger") {
        return true;
    } else {
        return false;
    }
}
</code></pre>

<p>后端判断也很简单，比如php</p>

<pre><code class="language-php">function is_weixin(){ if ( strpos($_SERVER['HTTP_USER_AGENT'], 'MicroMessenger') !== false ) { return true; } return false;}
</code></pre>

<p>###库的使用实践</p>

<p>zepto.js</p>

<p><a href="http://chaoskeh.com/blog/some-experience-of-using-zepto.html">zepto的一篇使用注意点讲解</a></p>

<p><a href="http://blog.youyo.name/archives/zepto-tap-click-through-research.html">zepto的著名的tap“点透”bug</a></p>

<p><a href="http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html">zepto源码注释</a></p>

<p>###跨域问题</p>

<p>手机浏览器也是浏览器，在ajax调用外部api的时候也存在跨域问题。当然利用phonegap打包后，由于协议不一样就不存在跨域问题了。 但页面通常是需要跟后端进行调试的。一般会报类似</p>

<pre><code class="language-js">XMLHttpRequest cannot load XXX
Origin null is not allowed by Access-Control-Allow-Origin.
</code></pre>

<p>以及</p>

<pre><code class="language-js">XMLHttpRequest cannot load http://. Request header field Content-Type is not allowed by Access-Control-Allow-Headers."
</code></pre>

<p>这时候可以让后端加上两个http头</p>

<pre><code class="language-js">
Access-Control-Allow-Origin "*"
Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept"
</code></pre>

<p>第一个头可以避免跨域问题，第二个头可以方便ajax请求设置content-type等配置项</p>

<p>###调试篇</p>

<p>手机抓包与配host</p>

<p>在PC上，我们可以很方便地配host，但是手机上如何配host，这是一个问题。</p>

<p>这里主要使用fiddler和远程代理，实现手机配host的操作，具体操作如下：</p>

<p>首先，保证PC和移动设备在同一个局域网下；</p>

<p>PC上开启fiddler，并在设置中勾选“allow remote computers to connect”</p>

<p>首先，保证PC和移动设备在同一个局域网下；</p>

<p>PC上开启fiddler，并在设置中勾选“allow remote computers to connect”</p>

<p>手机上设置代理，代理IP为PC的IP地址，端口为8888（这是fiddler的默认端口）。通常手机上可以直接设置代理，如果没有，可以去下载一个叫ProxyDroid的APP来实现代理的设置。</p>

<p>此时你会发现，用手机上网，走的其实是PC上的fiddler，所有的请求包都会在fiddler中列出来，配合willow使用，即可实现配host，甚至是反向代理的操作。</p>

<p>###相关收藏</p>

<p><a href="https://github.com/AlloyTeam/Mars">腾讯移动Web前端知识库</a></p>

<p>一些非常重要的工具类网站</p>

<p><a href="http://ww1.sinaimg.cn/bmiddle/c2c57f68jw1e4fh7dmw12j20fi2w6qe1.jpg">移动端手势表</a></p>

<p><a href="http://ued.ctrip.com/webkitcss/index.html">webkit独有的样式分析</a></p>


		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-2/">
		        移动端上前端开发的一些问题与总结（2）
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年05月12日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/html5/">html5</a>, <a href="/tags/移动开发/">移动开发</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>###使用特殊链接：</p> <p>如果你关闭自动识别后 ，又希望某些电话号码能够链接到 iPhone 的拨号功能 ，那么可以通过这样来声明电话链接 ,</p> <pre><code class="language-html">&lt;a href="tel:12345654321"&gt;打电话给我&lt;/a&gt; &lt;a href="sms:12345654321"&gt;发短信&lt;/a&gt; </code></pre> <p>或用于单元格：</p> <pre><code class="language-html">&lt;td onclick="location.href='tel:122'"&gt;&lt;/td&gt; </code></pre> <p>“文本”描述属性的特定文字样式，间距和自动滚屏。</p> <pre><code class="language-css">text-shadow: #00FFFC 10px 10px 5px; text-transform: capitalize; 常量：capitalize/lowercase/none/uppercase word-wrap: break-word; 常量：break-word/normal -webkit-marquee: right large infinite normal 10s; 常量：direction(方向) increment(迭代次数) repetition(重复) style(样式) speed(速度); -webkit-marquee-direction: ahead/auto/backwards/down/forwards/left/reverse/right/up -webkit-marquee-incrementt: 1-n/infinite(无穷次) -webkit-marquee-speed: fast/normal/slow -webkit-marquee-style: alternate/none/scroll/slide -webkit-text-fill-color: #ff6600; 常量：capitalize, lowercase, none, uppercase -webkit-text-security: circle; 常量：circle/disc/none/square -webkit-text-size-adjust: none; 常量:auto/none; -webkit-text-stroke: 15px #fff; -webkit-line-break: after-white-space; 常量：normal/after-white-space -webkit-appearance: caps-lock-indicator; -webkit-nbsp-mode: space; 常量： normal/space -webkit-rtl-ordering: logical; 常量：visual/logical -webkit-user-drag: element; 常量：element/auto/none -webkit-user-modify: read- only; 常量：read-write-plaintext-only/read-write/read-only -webkit-user-select: text; 常量：text/auto/none </code></pre> <p>“表格”描述的布局和设计性能表的具体内容。</p> <pre><code class="language-css">-webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; -webkit-column-break-after: right; 常量：always/auto/avoid/left/right -webkit-column-break-before: right; 常量：always/auto/avoid/left/right –webkit-column-break-inside: logical; 常量：avoid/auto -webkit-column-count: 3; //分栏 -webkit-column-rule: 1px solid #fff; style:dashed,dotted,double,groove,hidden,inset,none,outset,ridge,solid </code></pre> <p>“用户界面”描述属性，涉及到用户界面元素在浏览器中，如滚动文字区，滚动条，等等。报告还描述属性，范围以外的网页内容，如光标的标注样式和显示当您按住触摸触摸 目标，如在iPhone上的链接。</p> <pre><code class="language-css">-webkit-box-align: baseline,center,end,start,stretch 常量：baseline/center/end/start/stretch -webkit-box-direction: normal;常量：normal/reverse -webkit-box-flex: flex_valuet -webkit-box-flex-group: group_number -webkit-box-lines: multiple; 常量：multiple/single -webkit-box-ordinal-group: group_number -webkit-box-orient: block-axis; 常量：block-axis/horizontal/inline-axis/vertical/orientation –webkit-box-pack: alignment; 常量：center/end/justify/start </code></pre> <p>动画过渡 这是 Webkit 中最具创新力的特性：使用过渡函数定义动画。</p> <pre><code class="language-css">-webkit-animation: title infinite ease-in-out 3s; animation 有这几个属性： -webkit-animation-name： //属性名，就是我们定义的keyframes -webkit-animation-duration：3s //持续时间 -webkit-animation-timing-function： //过渡类型：ease/ linear(线性) /ease-in(慢到快)/ease-out(快到慢) /ease-in-out(慢到快再到慢) /cubic-bezier -webkit-animation-delay：10ms //动画延迟(默认0) -webkit-animation-iteration-count： //循环次数(默认1)，infinite 为无限 -webkit-animation-direction： //动画方式：normal(默认 正向播放)； alternate(交替方向，第偶数次正向播放，第奇数次反向播放) </code></pre> <p>这些同样是可以简写的。但真正让我觉的很爽的是keyframes，它能定义一个动画的转变过程供调用，过程为0%到100%或from(0%)到to(100%)。简单点说，只要你有想法，你想让元素在这个过程中以什么样的方式改变都是很简单的。</p> <p>-webkit-transform: 类型（缩放scale/旋转rotate/倾斜skew/位移translate） scale(num,num) 放大倍率。scaleX 和 scaleY(3)，可以简写为：scale(* , <em>) rotate(</em>deg) 转动角度。rotateX 和 rotateY，可以简写为：rotate(* , <em>) Skew(</em>deg) 倾斜角度。skewX 和skewY，可简写为：skew(* , <em>) translate(</em>,<em>) 坐标移动。translateX 和translateY，可简写为：translate(</em> , *)。 ___</p> <p>###锁定 viewport</p> <pre><code class="language-js">ontouchmove="event.preventDefault()" //锁定viewport，任何屏幕操作不移动用户界面（弹出键盘除外）。 </code></pre> <hr /> <p>###被点击元素的外观变化，可以使用样式来设定：</p> <p>-webkit-tap-highlight-color: 颜色</p> <hr /> <p>###侦测iPhone/iPod</p> <p>开发特定设备的移动网站，首先要做的就是设备侦测了。下面是使用Javascript侦测iPhone/iPod的UA，然后转向到专属的URL。</p> <pre><code class="language-js">if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i))) { if (document.cookie.indexOf("iphone_redirect=false") == -1) { window.location = "http://m.example.com"; } } </code></pre> <hr /> <p>###阻止旋转屏幕时自动调整字体大小</p> <pre><code class="language-css">html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 {-webkit-text-size-adjust:none;} </code></pre> <hr /> <p>###模拟:hover伪类</p> <p>因为iPhone并没有鼠标指针，所以没有hover事件。那么CSS :hover伪类就没用了。但是iPhone有Touch事件，onTouchStart 类似 onMouseOver，onTouchEnd 类似 onMouseOut。所以我们可以用它来模拟hover。使用Javascript：</p> <pre><code class="language-js">var myLinks = document.getElementsByTagName('a'); for(var i = 0; i &lt; myLinks.length; i++){ myLinks[i].addEventListener('touchstart', function(){ this.className = 'hover'; }, false); myLinks[i].addEventListener('touchend', function(){ this.className = '';}, false); } </code></pre> <hr /> <p>###flexbox布局模板</p> <p><a href="http://jsbin.com/ibuwol/2/edit">flex模板</a></p> <p><a href="http://www.w3cplus.com/blog/666.html">深入了解flex布局</a></p> <hr /> <p>###测试是否支持svg图片</p> <pre><code class="language-js">document.implementation.hasFeature("http:// www.w3.org/TR/SVG11/feature#Image", "1.1"); </code></pre> <hr /> <p>###消除transition闪屏</p> <p>两个方法</p> <pre><code...
		    <p>
		    <a class="text" href="/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-2/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-1/">
		        移动端上前端开发的一些问题与总结（1）
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年04月24日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/html5/">html5</a>, <a href="/tags/移动开发/">移动开发</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>在工作中遇到的一些问题和fix方法，做一个汇总：</p> <p>###样式表:</p> <pre><code class="language-html">&lt;link rel="apple-touch-startup-image" href="startup.png" /&gt; // 设置开始页面图片 &lt;link rel="apple-touch-icon" href="iphon_tetris_icon.png"/&gt; // 在设置书签的时候可以显示好看的图标 &lt;link rel="stylesheet" media="all and (orientation:portrait)" href="portrait.css"&gt; // 肖像模式样式 &lt;link rel="stylesheet" media="all and (orientation:landscape)"href="landscape.css"&gt; // 风景模式样式 //竖屏时使用的样式 &lt;style media="all and (orientation:portrait)" type="text/css"&gt; #landscape { display: none; } &lt;/style&gt; //横屏时使用的样式 &lt;style media="all and (orientation:landscape)" type="text/css"&gt;#portrait { display: none; }&lt;/style&gt; </code></pre> <p>###meta标签:</p> <p>这些meta标签在开发webapp时起到非常重要的作用</p> <pre><code class="language-html">&lt;meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" /&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable" /&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style" /&gt; &lt;meta content="telephone=no" name="format-detection" /&gt; </code></pre> <p>第一个meta标签表示：强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览；</p> <p>其中：</p> <p>width - viewport的宽度</p> <p>height - viewport的高度</p> <p>initial-scale - 初始的缩放比例</p> <p>minimum-scale - 允许用户缩放到的最小比例</p> <p>maximum-scale - 允许用户缩放到的最大比例</p> <p>user-scalable - 用户是否可以手动缩放</p> <p>第二个meta标签是iphone设备中的safari私有meta标签，它表示：允许全屏模式浏览；</p> <p>第三个meta标签也是iphone的私有标签，它指定的iphone中safari顶端的状态条的样式；</p> <p>第四个meta标签表示：告诉设备忽略将页面中的数字识别为电话号码</p> <p>###页面描述(iOS)</p> <pre><code class="language-html">&lt;link rel="apple-touch-icon-precomposed" href="http://www.xxx.com/App_icon_114.png" /&gt; &lt;link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://www.xxx.com/App_icon_72.png" /&gt; &lt;link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://www.xxx.com/App_icon_114.png" /&gt; </code></pre> <p>这个属性是当用户把连接保存到手机桌面时使用的图标，如果不设置，则会用网页的截图。有了这，就可以让你的网页像APP一样存在手机里了</p> <pre><code class="language-html">&lt;link rel="apple-touch-startup-image" href="/img/startup.png" /&gt; </code></pre> <p>这个是APP启动画面图片，用途和上面的类似，如果不设置，启动画面就是白屏，图片像素就是手机全屏的像素</p> <pre><code class="language-html">&lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /&gt; </code></pre> <p>这个描述是表示打开的web app的最上面的时间、信号栏是黑色的，当然也可以设置其它参数，详细参数说明在：Supported Meta Tags</p> <pre><code class="language-html">&lt;meta name="apple-touch-fullscreen" content="yes" /&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; </code></pre> <p>这2个描述也很有用的，如果没有它，你的web app会用safari浏览器打开，有了它，就会用独立进程的无地址栏的打开，完全可以和普通的APP比拟了</p> <p>下面还有个不错的css，是用来区分视网膜屏幕的，这样你可以在iphone这样的手机里载入2x的图片，就不会模糊了</p> <pre><code class="language-css"> @media only screen and (-webkit-min-device-pixel-ratio:1.5),only screen and (min--moz-device-pixel-ratio:1.5),only screen and (min-device-pixel-ratio:1.5),only screen and (min-resolution:200dpi) { #logo{background-image: url(logo@2x.png);} } </code></pre> <p>###关于点击和click事件</p> <p>对于a标记的点击导航，默认是在onclick事件中处理的。而移动客户端对onclick的响应相比PC浏览器有着明显的几百毫秒延迟。</p> <p>在移动浏览器中对触摸事件的响应顺序应当是：</p> <p>ontouchstart -&gt; ontouchmove -&gt; ontouchend -&gt; onclick 因此，如果确实要加快对点击事件的响应，就应当绑定ontouchend事件。</p> <p>使用click会出现绑定点击区域闪一下的情况，解决：给该元素一个样式如下</p> <pre><code class="language-css">-webkit-tap-highlight-color: rgba(0,0,0,0); </code></pre> <p>如果不使用click，也不能简单的用touchstart或touchend替代，需要用touchstart的模拟一个click事件，并且不能发生touchmove事件，或者用zepto中的tap（轻击）事件。</p> <pre><code class="language-css">body{-webkit-overflow-scrolling: touch;} </code></pre> <p>用iphone或ipad浏览很长的网页滚动时的滑动效果很不错吧？不过如果是一个div，然后设置height:200px;overflow:auto;的话，可以滚动但是完全没有那滑动效果，很郁闷吧？ 我看到很多网站为了实现这一效果，用了第三方类库，最常用的是iscroll（包括新浪手机页，百度等） 我一开始也使用，不过自从用了-webkit-overflow-scrolling:touch;样式后，就完全可以抛弃第三方类库了，把它加在body{}区域，所有的overflow需要滚动的都可以生效了。</p> <p>###手机浏览器常用手势动作监听封装(配合zepto,from mansonchor)</p> <p><a href="http://wo.poco.cn/manson/post/id/268780" alt="手机浏览器常用手势动作监听封装">手机浏览器常用手势动作监听封装</a></p> <p>###事件：(参考：引用了指尖上的js系列，在此向作者表示感谢) <a href="http://www.cnblogs.com/pifoo/archive/2011/05/23/webkit-touch-event-1.html">对于Touch的处理</a> <a href="http://www.cnblogs.com/pifoo/archive/2011/05/22/webkit-touch-event-2.html">处理简单手势</a></p> <p><a href="http://www.cnblogs.com/pifoo/archive/2011/05/22/webkit-touch-event-3.html">处理复杂手势</a></p> <p>###手势事件</p> <p>touchstart //当手指接触屏幕时触发</p> <p>touchmove //当已经接触屏幕的手指开始移动后触发</p> <p>touchend //当手指离开屏幕时触发</p> <p>touchcancel</p> <p>###触摸事件</p> <p>gesturestart //当两个手指接触屏幕时触发</p> <p>gesturechange //当两个手指接触屏幕后开始移动时触发</p> <p>gestureend</p> <p>###屏幕旋转事件</p> <p>onorientationchange //检测触摸屏幕的手指何时改变方向</p> <p>orientationchange //touch事件支持的相关属性</p> <p>touches</p> <p>targetTouches</p> <p>changedTouches</p> <p>clientX　　　　// X coordinate of touch relative to the viewport (excludes scroll offset)</p> <p>clientY　　　　// Y coordinate of touch relative to the viewport (excludes scroll offset)</p> <p>screenX　　　 // Relative to the screen</p> <p>screenY 　　 // Relative to the screen</p> <p>pageX　　 　　// Relative to the full page (includes scrolling)</p> <p>pageY　　　　 // Relative to the full page (includes scrolling)</p> <p>target　　　　 // Node the touch event originated from</p> <p>identifier　　 // An identifying number, unique to each touch event</p> <p>屏幕旋转事件：onorientationchange 添加屏幕旋转事件侦听，可随时发现屏幕旋转状态（左旋、右旋还是没旋）</p>...
		    <p>
		    <a class="text" href="/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-1/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/zepto-lazyload%E5%9B%BE%E7%89%87/">
		        zepto lazyload图片
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年04月24日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/zepto/">zepto</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>图片懒加载有很多js插件，非常著名的属jQuery的Lazy Load了。自己做手机项目上也需要图片懒加载，而且手机上的图片懒加载有两种：一种是普通img标签的，一种是div标签（或者其他标签）上加背景图片的。所以就练手写了个支持以上两种情况的Zepto小插件。</p>

<p>###功能：
支持img标签图片懒加载、div标签（或者其他标签）的背景图片懒加载；
支持预加载。默认是图片出现在屏幕时开始加载，可以设置threshold参数，如threshold:100，此时图片出现在屏幕之前100px时开始加载；
背景图片懒加载时，自动添加base64的1*1透明图片做默认背景图。也可以自定义默认背景图，参数为placeholder。
###使用方法：</p>

<p>引用1.1.3的Zepto（我只测过这个目前最新版），并引用picLazyLoad.js</p>

<pre><code class="language-html">
&lt;script src="1.1.3/zepto.min.js"&gt;&lt;/script&gt;
&lt;script src="1.0/zepto.picLazyLoad.min.js"&gt;&lt;/script&gt;

</code></pre>
<p>在要懒加载的标签上，加类名或者id名，方便调用。在标签上加data-original=”original.jpg”，original.jpg为实际加载图片路径。如果是img标签，还需要加src=”blank.png”。blank.png为默认背景图，建议用base64图。例如：</p>

<pre><code class="language-html">&lt;img class="test-lazyload" src="blank.png" data-original="original.jpg"&gt;&lt;div class="test-lazyload" data-original="original.jpg"&gt;&lt;/div&gt;
</code></pre>

<p><strong><em>调用:</em></strong></p>

<pre><code class="language-javascript">
$('.test-lazyload').picLazyLoad();
</code></pre>

<p>如需加参数：</p>

<pre><code class="language-javascript">
$('.test-lazyload').picLazyLoad({
    threshold: 100,
    placeholder: 'http://image.yihaodianimg.com/front-homepage/global/images/blank.gif'
});
</code></pre>
<p><a href="http://ons.me/wp-content/uploads/2014/05/picLazyLoad/">→示例DEMO←</a></p>

<ul>
  <li>已知问题：
iPhone 5S 7.1.1里，所有浏览器，网页滑到下面，刷新网页，不执行onscroll方法，获取不到scrolltop值。导致此时刷新网页，网页下方的图片没有默认加载。</li>
  <li>
    <p>待增加功能：
现在是直接显示图片show，以后增加fadeIn图片淡入；
现在是只能根据窗口懒加载图片，待增加根据容器、tab选项卡等。</p>
  </li>
  <li>小提示：
使用背景图片比使用img标签懒加载浏览器显示速度要快，不知道是不是后者多了一步替换src路径操作导致的；
如果要兼容更多的设备，使用背景图片可以显示更清晰，因为可以设置background-size，之前的文章有提到过。</li>
</ul>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E4%B9%9D%E7%A7%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">
		        九种浏览器端缓存机制
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年04月12日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。浏览器端缓存的机制种类较多，总体归纳为九种，这里详细分析下这九种缓存机制的原理和使用场景。打开浏览器的调试模式-&gt;resources左侧就有浏览器的8种缓存机制:</p> <p><img src="/img/post/1405121.jpg" alt="" /></p> <p>一、http缓存</p> <p>  http缓存是基于HTTP协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件，chrome控制台下的Frames即展示的是浏览器的http文件级缓存。以下是浏览器缓存的整个机制流程。主要是针对重复的http请求，在有缓存的情况下判断过程主要分3步：</p> <ul> <li>判断expires，如果未过期，直接读取http缓存文件，不发http请求，否则进入下一步</li> <li>判断是否含有etag，有则带上if-none-match发送请求，未修改返回304，修改返回200，否则进入下一步</li> <li>判断是否含有last-modified，有则带上if-modified-since发送请求，无效返回200，有效返回304，否则直接向服务器请求</li> </ul> <p><img src="/img/post/1405122.jpg" alt="" /></p> <p>如果通过etag和last-modified判断，即使返回304有至少有一次http请求，只不过返回的是304的返回内容，而不是文件内容。所以合理设计实现expires参数可以减少较多的浏览器请求。</p> <p>二、websql</p> <p>   websql这种方式只有较新的chrome浏览器支持，并以一个独立规范形式出现，主要有以下特点</p> <ul> <li>Web Sql 数据库API 实际上不是HTML5规范的组成部分；</li> <li>在HTML5之前就已经存在了，是单独的规范；</li> <li>它是将数据以数据库的形式存储在客户端，根据需求去读取；</li> <li>跟Storage的区别是： Storage和Cookie都是以键值对的形式存在的；</li> <li>Web Sql 更方便于检索，允许sql语句查询；</li> <li>让浏览器实现小型数据库存储功能；</li> <li>这个数据库是集成在浏览器里面的，目前主流浏览器基本都已支持；</li> </ul> <p>  websql API主要包含三个核心方法：</p> <ul> <li>openDatabase : 这个方法使用现有数据库或创建新数据库创建数据库对象。</li> <li>transaction : 这个方法允许我们根据情况控制事务提交或回滚。</li> <li>*executeSql : 这个方法用于执行真实的SQL查询。    openDatabase方法可以打开已经存在的数据库，不存在则创建</li> </ul> <pre><code class="language-js"> var db = openDatabase('mydatabase', '2.0', 'my db', 2 * 1024); </code></pre> <p>openDatabasek中五个参数分别为：数据库名、版本号、描述、数据库大小、创建回调。创建回调没有也可以创建数据库。</p> <p>database.transaction() 函数用来查询，executeSql()用于执行sql语句</p> <p>  例如在mydatabase数据库中创建表t1：</p> <pre><code class="language-js"> var db = openDatabase(' mydatabase ', '1.0', 'Test DB', 2 * 1024 * 1024); db.transaction(function (tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS t1 (id unique, log)'); }); </code></pre> <p>  插入操作</p> <pre><code class="language-js">var db = openDatabase('mydatabase', '2.0', 'my db', 2 * 1024); db.transaction(function (tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS t1 (id unique, log)'); tx.executeSql('INSERT INTO t1 (id, log) VALUES (1, "foobar")'); tx.executeSql('INSERT INTO t1 (id, log) VALUES (2, "logmsg")'); }); </code></pre> <p>  在插入新记录时，我们还可以传递动态值，如：</p> <pre><code class="language-js"> var db = openDatabase(' mydatabase ', '2.0', 'my db', 2 * 1024); db.transaction(function (tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS t1 (id unique, log)'); tx.executeSql('INSERT INTO t1 (id,log) VALUES (?, ?'), [e_id, e_log]; //e_id和e_log是外部变量 }); </code></pre> <p>  读操作，如果要读取已经存在的记录，我们使用一个回调捕获结果：</p> <pre><code class="language-js"> var db = openDatabase(mydatabase, '2.0', 'my db', 2*1024); db.transaction(function (tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS t1 (id unique, log)'); tx.executeSql('INSERT INTO t1 (id, log) VALUES (1, "foobar")'); tx.executeSql('INSERT INTO t1 (id, log) VALUES (2, "logmsg")'); }); db.transaction(function (tx) { tx.executeSql('SELECT * FROM t1, [], function (tx, results) { var len = results.rows.length, i; msg = "&lt;p&gt;Found rows: " + len + "&lt;/p&gt;"; document.querySelector('#status').innerHTML += msg; for (i = 0; i &lt; len; i++){ alert(results.rows.item(i).log ); } }, null); }); </code></pre> <p>三、indexDB</p> <p>  IndexedDB 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。虽然 DOM 存储 对于存储少量数据是非常有用的，但是它对大量结构化数据的存储就显得力不从心了。IndexedDB 则提供了这样的一个解决方案。   IndexedDB 分别为同步和异步访问提供了单独的 API 。同步 API 本来是要用于仅供 Web Workers 内部使用，但是还没有被任何浏览器所实现。异步 API 在 Web Workers 内部和外部都可以使用，另外浏览器可能对indexDB有50M大小的限制，一般用户保存大量用户数据并要求数据之间有搜索需要的场景。</p> <ul> <li> <p>异步API   异步 API 方法调用完后会立即返回，而不会阻塞调用线程。要异步访问数据库，要调用 window 对象 indexedDB 属性的 open() 方法。该方法返回一个 IDBRequest 对象 (IDBOpenDBRequest)；异步操作通过在...
		    <p>
		    <a class="text" href="/blog/%E4%B9%9D%E7%A7%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AFh5%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D%E7%82%B9%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E/">
		        移动端h5拨打电话点标签说明
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年03月28日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/html5/">html5</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>html5中经常使用的电话协议如下:</p>

<p>客户端       协议类型</p>

<p>iphone_uc   ：etel</p>

<p>iphone      ：tel</p>

<p>android_uc  ：tel</p>

<p>android     ：wtai</p>

<p>default_uc  ：wtai</p>

<p>default     ：wtai</p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/nodejs-npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
		        nodejs npm常用命令
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2015年01月9日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/nodejs/">nodejs</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>npm是一个node包管理和分发工具，已经成为了非官方的发布node模块（包）的标准。有了npm，可以很快的找到特定服务要使用的包，进行下载、安装以及管理已经安装的包。</p>

<p>1、npm install moduleNames：安装Node模块
安装完毕后会产生一个node_modules目录，其目录下就是安装的各个node模块。</p>

<p>node的安装分为全局模式和本地模式。
一般情况下会以本地模式运行，包会被安装到和你的应用程序代码的本地node_modules目录下。
在全局模式下，Node包会被安装到Node的安装目录下的node_modules下。</p>

<p>全局安装命令为$npm install -g moduleName。
获知使用$npm set global=true来设定安装模式，$npm get global可以查看当前使用的安装模式。</p>

<p>示例：
npm install express 
默认会安装express的最新版本，也可以通过在后面加版本号的方式安装指定版本，如npm install express@3.0.6</p>

<p>npm install <name> -g 
将包安装到全局环境中</name></p>

<p>但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的，就好像全局安装了vmarket后，就可以在命令行中直接运行vm命令</p>

<p>npm install <name> --save 
安装的同时，将信息写入package.json中项目路径中如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包，这样代码提交到github时，就不用提交node_modules这个文件夹了。</name></p>

<p>2、npm view moduleNames：查看node模块的package.json文件夹
注意事项：如果想要查看package.json文件夹下某个标签的内容，可以使用$npm view moduleName labelName</p>

<p>3、npm list：查看当前目录下已安装的node包
注意事项：Node模块搜索是从代码执行的当前目录开始的，搜索结果取决于当前使用的目录中的node_modules下的内容。$ npm list parseable=true可以目录的形式来展现当前安装的所有node包</p>

<p>4、npm help：查看帮助命令</p>

<p>5、npm view moudleName dependencies：查看包的依赖关系</p>

<p>6、npm view moduleName repository.url：查看包的源文件地址</p>

<p>7、npm view moduleName engines：查看包所依赖的Node的版本</p>

<p>8、npm help folders：查看npm使用的所有文件夹</p>

<p>9、npm rebuild moduleName：用于更改包内容后进行重建</p>

<p>10、npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新</p>

<p>11、npm update moduleName：更新node模块</p>

<p>12、npm uninstall moudleName：卸载node模块</p>

<p>13、一个npm包是包含了package.json的文件夹，package.json描述了这个文件夹的结构。访问npm的json文件夹的方法如下：
$ npm help json 
此命令会以默认的方式打开一个网页，如果更改了默认打开程序则可能不会以网页的形式打开。</p>

<p>14、发布一个npm包的时候，需要检验某个包名是否已存在
$ npm search packageName</p>

<p>15、npm init：会引导你创建一个package.json文件，包括名称、版本、作者这些信息等</p>

<p>16、npm root：查看当前包的安装路径
npm root -g：查看全局的包的安装路径</p>

<p>17、npm -v：查看npm安装的版本</p>

<p>更多命令请参看npm官方文档：https://www.npmjs.org/doc/</p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/window.attachEvent%E5%92%8Cwindow.addEventListener%E7%9A%84%E5%8C%BA%E5%88%AB/">
		        谈谈attachEvent和addEventListener
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年12月27日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/javascript/">Javascript</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>以前写JavaScript脚本时，事件都采用object.event = handler的方式绑定。这种方式对于Internet Explorer、Mozilla/Firefox和Opera来说很通用。但有一个问题，这种方式只能一个事件对应一个事件处理过程。如果希望一个事件可以依次执执行多个处理过程，就不好用了。</p> <p>Internet Explorer从5.0开始，提供了一个attachEvent方法，使用这个方法，可以一个事件，绑定多个处理过程。但是Mozilla/Firefox并不支持这个方法，它使用另外一个方法addEventListener。它们之间有少许区别，在attachEvent方法中，事件是以”on”开头的，而addEventListener，事件不是以”on”开头，另外，addEventListener还有第三个参数，一般指定false就可以。 因此，在程序中，给一个事件指派多个处理过程的话。需要根据不同的浏览器，选择使用attachEvent和addEventListener。示例如下：</p> <pre><code class="language-javascript">if (window.attachEvent) //IE window.attachEvent("onload", foo); } else if (window.addEventListener) { //IE8以后有以及Mozilla/Firefox window.addEventListener("load", foo, false); } function foo() { alert("ok"); } </code></pre> <p>注释：attachEvent所绑定的多个方法的执行顺序是随机的，因此，这几个方法之间，不要有顺序依赖。另外，attachEvent和addEventListener不仅仅适用于window对象，其他的一些对象，也支持该方法</p> <p>注意： Internet Explorer 8 及更早IE版本不支持 addEventListener() 方法，，Opera 7.0 及 Opera 更早版本也不支持。 但是，对于这些不支持该函数的浏览器，你可以使用 attachEvent() 方法来添加事件句柄 (查看 “更多实例” 了解跨浏览器的解决方案)。</p> <p>实例 为 &lt; button&gt; 元素添加点击事件。 当用户点击按钮时，在 id=”demo” 的 &lt; p&gt; 元素上输出 “Hello World” :</p> <pre><code class="language-javascript">document.getElementById("myBtn").addEventListener("click", function(){ document.getElementById("demo").innerHTML = "Hello World"; }); </code></pre> <hr /> <p>上面这种绑定事件的方式，兼容主流浏览器,但如果一个元素上添加多次同一事件呢？</p> <p>obj.onclick=method1;</p> <p>obj.onclick=method2;</p> <p>obj.onclick=method3;</p> <p>如果这样写,那么只有最后绑定的事件,这里是method3会被执行,这个时候我们就不能用onclick这样的写法了,主角该登场了,在IE中我们可以使用attachEvent方法：</p> <p>//object.attachEvent(event,function);</p> <p>btn1Obj.attachEvent(“onclick”,method1);</p> <p>btn1Obj.attachEvent(“onclick”,method2);</p> <p>btn1Obj.attachEvent(“onclick”,method3);</p> <p>使用格式是前面是事件类型,注意的是需要加on,比如onclick,onsubmit,onchange,执行顺序是</p> <blockquote> <p>method3-&gt;method2-&gt;method1</p> </blockquote> <p>可惜这个微软的私人方法,火狐和其他浏览器都不支持,幸运的是他们都支持W3C标准的addEventListener方法：</p> <p>//element.addEventListener(type,listener,useCapture);</p> <p>btn1Obj.addEventListener(“click”,method1,false);</p> <p>btn1Obj.addEventListener(“click”,method2,false);</p> <p>btn1Obj.addEventListener(“click”,method3,false); 执行顺序为</p> <blockquote> <p>method1-&gt;method2-&gt;method3</p> </blockquote> <p>做前端开发工程师,最悲剧的某过于浏览器兼容问题了,上面有两种添加事件的方法,为了同一添加事件的方法,我们不得不再重新写一个通用的添加事件函数,幸亏有前人帮我们做了这件事：</p> <pre><code class="language-javascript"> addEvent(elm, evType, fn, useCapture) { if (elm.addEventListener) { elm.addEventListener(evType, fn, useCapture);//DOM2.0 return true; }else if (elm.attachEvent) { var r = elm.attachEvent('on' + evType, fn);//IE5+ return r; }else { elm['on' + evType] = fn;//DOM 0 } } </code></pre> <p><em>下面是Dean Edwards 的版本</em></p> <pre><code class="language-javascript">function addEvent(element, type, handler) { //为每一个事件处理函数分派一个唯一的ID if (!handler.$$guid) handler.$$guid = addEvent.guid++; //为元素的事件类型创建一个哈希表 if (!element.events) element.events = {}; //为每一个"元素/事件"对创建一个事件处理程序的哈希表 var handlers = element.events[type]; if (!handlers) { handlers = element.events[type] = {}; //存储存在的事件处理函数(如果有) if (element["on" + type]) { handlers[0] = element["on" + type]; } } //将事件处理函数存入哈希表 handlers[handler.$$guid] = handler; //指派一个全局的事件处理函数来做所有的工作 element["on" + type] = handleEvent; }; //用来创建唯一的ID的计数器 addEvent.guid = 1; function removeEvent(element, type, handler) { //从哈希表中删除事件处理函数 if (element.events &amp;&amp; element.events[type]) { delete element.events[type][handler.$$guid]; } }; function handleEvent(event) { var returnValue = true; //抓获事件对象(IE使用全局事件对象) event = event || fixEvent(window.event); //取得事件处理函数的哈希表的引用 var handlers = this.events[event.type]; //执行每一个处理函数 for (var i in handlers) { this.$$handleEvent = handlers[i]; if (this.$$handleEvent(event) === false) { returnValue = false; } } return returnValue; }; //为IE的事件对象添加一些“缺失的”函数 function fixEvent(event) { //添加标准的W3C方法 event.preventDefault = fixEvent.preventDefault; event.stopPropagation = fixEvent.stopPropagation; return event; }; fixEvent.preventDefault = function() { this.returnValue = false; }; fixEvent.stopPropagation = function() { this.cancelBubble = true; }; </code></pre> <p>功能非常强悍，解决IE的this指向问题，event总是作为第一个参数传入，跨浏览器就更不在话下。</p> <p>最后贡献一个HTML5工作组的版本：</p> <pre><code class="language-javascript">var addEvent=(function(){ if(document.addEventListener){ return function(el,type,fn){ if(el.length){ for(var i=0;i&lt;el.length;i++){ addEvent(el[i],type,fn); } }else{ el.addEventListener(type,fn,false); } };...
		    <p>
		    <a class="text" href="/blog/window.attachEvent%E5%92%8Cwindow.addEventListener%E7%9A%84%E5%8C%BA%E5%88%AB/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/DOM%E6%A0%87%E5%87%86%E4%B8%8EIE%E7%9A%84html%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%8C%BA%E5%88%AB-%E8%BD%AC%E8%BD%BD/">
		        DOM标准与IE的html事件模型区别（转载）
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年11月15日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/javascript/">Javascript</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p><strong>事件</strong></p> <p>HTML元素事件是浏览器内在自动产生的,当有事件发生时html元素会向外界(这里主要指元素事件的订阅者)发出各种事件,如click,onmouseover,onmouseout等等。</p> <p><strong>DOM事件流</strong></p> <p>DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素结点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。</p> <p><strong>主流浏览器的事件模型</strong></p> <p>早在2004前在HTML元素事件的订阅，发送，传播，处理模型上各浏览器实现并不一致，直到DOM Level3中规定后，多数主流浏览器才陆陆续续支持DOM标准的事件处理模型 — 捕获型与冒泡型。 目前除IE浏览器外，其它主流的Firefox, Opera, Safari都支持标准的DOM事件处理模型。IE仍然使用自己的模型，即冒泡型，它模型的一部份被DOM采用，这点对于开发者来说也是有好处的，只使用DOM标准，IE都共有的事件处理方式才能有效的跨浏览器。</p> <p><strong>冒泡型事件(Bubbling)</strong></p> <p>这是IE浏览器对事件模型的实现，也是最容易理解的，至少笔者觉得比较符合实际的。冒泡，顾名思义，事件像个水中的气泡一样一直往上冒，直到顶端。从DOM树型结构上理解，就是事件由叶子结点沿祖先结点一直向上传递直到根结点；从浏览器界面视图HTML元素排列层次上理解就是事件由具有从属关系的最确定的目标元素一直传递到最不确定的目标元素.</p> <p><strong>捕获型事件(Capturing)</strong></p> <p>Netscape Navigator的实现，它与冒泡型刚好相反，由DOM树最顶层元素一直到最精确的元素，这个事件模型对于开发者来说（至少是我..）有点费解，因为直观上的理解应该如同冒泡型，事件传递应该由最确定的元素，即事件产生元素开始。 但这个模型在某些情况下也是很有用的，接下来会讲解到。</p> <p><img src="/img/post/1412270.jpg" alt="" /></p> <p><strong>DOM标准事件模型</strong></p> <p>因为两个不同的模型都有其优点和解释，DOM标准支持捕获型与冒泡型，可以说是它们两者的结合体。它可以在一个DOM元素上绑定多个事件处理器，并且在处理函数内部，this关键字仍然指向被绑定的DOM元素，另外处理函数参数列表的第一个位置传递事件event对象。</p> <p>首先是捕获式传递事件，接着是冒泡式传递，所以，如果一个处理函数既注册了捕获型事件的监听，又注册冒泡型事件监听，那么在DOM事件模型中它就会被调用两次。</p> <p><img src="/img/post/1412271.jpg" alt="" /></p> <p>注册与移除事件监听器</p> <p>注册事件监听器，或又称订阅事件，当元素事件发生时浏览器回调该监听函数执行事件处理。目前主流浏览器中有两种注册事件的方法，一种是IE浏览器的，另一种是DOM标准的。</p> <p>1、直接JS或HTML挂载法</p> <pre><code class="language-html">&lt;div onclick="alert(this.innerHTML);"&gt; element.onclick = function(){alert(this.innerHTML);} </code></pre> <p>移除时将事件属性设为nul即可，这个也是最常用的方法了，优缺点也是显然的：</p> <p>简单方便，在HTML中直接书写处理函数的代码块，在JS中给元素对应事件属性赋值即可 IE与DOM标准都支持的一种方法，它在IE与DOM标准中都是在事件冒泡过程中被调用的。 可以在处理函数块内直接用this引用注册事件的元素 要给元素注册多个监听器，就不能用这方法了</p> <p>2、IE下注册多个事件监听器与移除监听器方法</p> <p>IE浏览器中HTML元素有个attachEvent方法允许外界注册该元素多个事件监听器,例如</p> <p>element.attachEvent(‘onclick’, observer); attachEvent接受两个参数。第一个参数是事件名称，第二个参数observer是回调处理函数。这里得说明一下，有个经常会出错的地方，IE下利用attachEvent注册的处理函数调用时this指向不再是先前注册事件的元素，这时的this为window对象了，笔者很奇怪IE为什么要这么做，完全看不出好处所在。 要移除先前注册的事件的监听器,调用element的detachEvent方法即可，参数相同。</p> <p>element.detachEvent(‘onclick’, observer); 3、 DOM标准下注册多个事件监听器与移除监听器方法</p> <p>实现DOM标准的浏览器与IE浏览器中注册元素事件监听器方式有所不同，它通过元素的addEventListener方法注册，该方法既支持注册冒泡型事件处理，又支持捕获型事件处理。</p> <p>element.addEventListener(‘click’, observer, useCapture); addEventListener方法接受三个参数。第一个参数是事件名称，值得注意的是，这里事件名称与IE的不同，事件名称是没’on’开头的;第二个参数observer是回调处理函数;第三个参数注明该处理回调函数是在事件传递过程中的捕获阶段被调用还是冒泡阶段被调用</p> <p>移除已注册的事件监听器调用element的removeEventListener即可，参数不变.</p> <p>element.removeEventListener(‘click’, observer, useCapture);</p> <p>跨浏览器的注册与移除元素事件监听器方案</p> <p>弄清楚DOM标准与IE的注册元素事件监听器之间的异同后，就可以实现一个跨浏览器的注册与移除元素事件监听器方案:</p> <pre><code class="language-javascript">//注册 function addEventHandler(element, evtName, callback, useCapture) { //DOM标准 if (element.addEventListener) { element.addEventListener(evtName, callback, useCapture); }else { //IE方式,忽略useCapture参数 element.attachEvent('on' + evtName, callback); } } //移除 function removeEventHandler(element, evtName, callback, useCapture) { //DOM标准 if (element.removeEventListener) { element.removeEventListener(evtName, callback, useCapture); }else { //IE方式,忽略useCapture参数 element.dettachEvent('on' + evtName, callback); } } </code></pre> <p>如何取消浏览器事件的传递与事件传递后浏览器的默认处理</p> <p>先说明取消事件传递与浏览器事件传递后的默认处理是两个不同的概念，可能很多同学朋友分不清，或者根本不存在这两个概念。</p> <p>取消事件传递是指，停止捕获型事件或冒泡型事件的进一步传递。例如上图中的冒泡型事件传递中，在body处理停止事件传递后，位于上层的document的事件监听器就不再收到通知，不再被处理。</p> <p>事件传递后的默认处理是指，通常浏览器在事件传递并处理完后会执行与该事件关联的默认动作（如果存在这样的动作）。例如，如果表单中input type 属性是 “submit”，点击后在事件传播完浏览器就就自动提交表单。又例如，input 元素的 keydown 事件发生并处理后，浏览器默认会将用户键入的字符自动追加到 input 元素的值中。</p> <p>要取消浏览器的件传递,IE与DOM标准又有所不同。</p> <p>在IE下,通过设置event对象的cancelBubble为true即可。</p> <pre><code class="language-javascript">function someHandle() { window.event.cancelBubble = true; } </code></pre> <p>DOM标准通过调用event对象的stopPropagation()方法即可。</p> <p>``javascript function someHandle(event) { event.stopPropagation(); }</p> <pre><code> 因些，跨浏览器的停止事件传递的方法是: ```javascript function someHandle(event) { event = event || window.event; if(event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true; } </code></pre> <p>取消事件传递后的默认处理，IE与DOM标准又不所不同。</p> <p>在IE下,通过设置event对象的returnValue为false即可。</p> <pre><code class="language-javascript">function someHandle() { window.event.returnValue = false; } </code></pre> <p>DOM标准通过调用event对象的preventDefault()方法即可。</p> <pre><code class="language-javascript">function someHandle(event) { event.preventDefault(); } </code></pre> <p>因些，跨浏览器的取消事件传递后的默认处理方法是：</p> <pre><code class="language-javascript">function someHandle(event) { event = event || window.event; if(event.preventDefault) event.preventDefault(); else event.returnValue = false; } </code></pre> <p>捕获型事件模型与冒泡型事件模型的应用场合</p> <p>标准事件模型为我们提供了两种方案，可能很多朋友分不清这两种不同模型有啥好处，为什么不只采取一种模型。 这里抛开IE浏览器讨论（IE只有一种，没法选择）什么情况下适合哪种事件模型。</p> <p>1、捕获型应用场合</p> <p>捕获型事件传递由最不精确的祖先元素一直到最精确的事件源元素，传递方式与操作系统中的全局快捷键与应用程序快捷键相似。当一个系统组合键发生时，如果注册了系统全局快捷键监听器，该事件就先被操作系统层捕获，全局监听器就先于应用程序快捷键监听器得到通知，也就是全局的先获得控制权，它有权阻止事件的进一步传递。所以捕获型事件模型适用于作全局范围内的监听，这里的全局是相对的全局，相对于某个顶层结点与该结点所有子孙结点形成的集合范围。</p> <p>例如你想作全局的点击事件监听，相对于document结点与document下所有的子结点，在某个条件下要求所有的子结点点击无效，这种情况下冒泡模型就解决不了了，而捕获型却非常适合，可以在最顶层结点添加捕获型事件监听器，伪码如下:</p> <pre><code class="language-javascript">if(canEventPass == false) { //取消事件进一步向子结点传递和冒泡传递 event.stopPropagation(); //取消浏览器事件后的默认执行 event.preventDefault(); } </code></pre> <p>这样一来，当canEventPass条件为假时，document下所有的子结点click注册事件都不会被浏览器处理。</p> <p>2、 冒泡型的应用场合</p> <p>可以说我们平时用的都是冒泡事件模型，因为IE只支持这模型。这里还是说说，在恰当利用该模型可以提高脚本性能。在元素一些频繁触发的事件中，如onmousemove, onmouseover,onmouseout,如果明确事件处理后没必要进一步传递，那么就可以大胆的取消它。此外，对于子结点事件监听器的处理会对父层监听器处理造成负面影响的，也应该在子结点监听器中禁止事件进一步向上传递以消除影响。</p> <p>综合案例分析</p> <p>最后结合下面HTML代码作分析:</p> <pre><code class="language-html">&lt;body onclick="alert('current is body');"&gt; &lt;div id="div0" onclick="alert('current is '+this.id)"&gt; &lt;div id="div1" onclick="alert('current is '+this.id)"&gt; &lt;div id="div2"&gt; &lt;div id="event_source" onclick="alert('current is '+this.id)" style="height:200px;width:200px;background-color:red;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; </code></pre> <p>HTML运行后点击红色区域,这是最里层的DIV,根据上面说明,无论是DOM标准还是IE,直接写在html里的监听处理函数是事件冒泡传递时调用的,由最里层一直往上传递,所以会先后出现 current is event_source current is div2 current is div1 current is div0 current is body</p> <p>添加以下片段:</p> <pre><code class="language-javascript">var div2 = document.getElementById('div2'); addEventHandler(div2,'click',function(event){ event = event || window.event; if(event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true; },false); </code></pre> <p>当点击红色区域后,根据上面说明,在泡冒泡处理期间,事件传递到div2后被停止传递了,所以div2上层的元素收不到通知,所以会先后出现:</p> <p>current is event_source current is div2</p> <p>在支持DOM标准的浏览器中,添加以下代码:</p> <pre><code class="language-javascript">document.body.addEventListener('click',function(event){ event.stopPropagation(); },true);...
		    <p>
		    <a class="text" href="/blog/DOM%E6%A0%87%E5%87%86%E4%B8%8EIE%E7%9A%84html%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%8C%BA%E5%88%AB-%E8%BD%AC%E8%BD%BD/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E8%A7%A3%E5%86%B3-%E5%9C%A8Mac-OS%E4%B8%8B%E5%BC%80%E5%8F%91html5+JS-Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8-%E8%B7%A8%E5%9F%9F-%E5%92%8C-%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/">
		        解决在Mac OS下开发html5+JS Chrome跨域和安全访问问题
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年10月12日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/javascript/">Javascript</a>, <a href="/tags/跨域/">跨域</a>, <a href="/tags/安全/">安全</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>从去年到今年一直从事 Hybrid开发模式，发现在mac os下开发html5 ＋js代码会遇到好多问题，各个浏览器兼容性 做的最好的就是chrome，chrome也是最好的调试工具。</p>

<p>而且我们在一个团队的开发中经常遇到 AJAX  请求跨域的问题，跨域是让人非常头疼的问题，或者遇到  Https  证书 没有授权的问题。这些问题在goolge 的 chrome 浏览器下都可以解决的， 方法是：</p>

<p>用命令行打开 Google Chrome 就好了</p>

<p>Mac os 下面用</p>

<pre><code class="language-javascript">
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --disable-web-security  
</code></pre>
<p>or</p>

<pre><code class="language-javascript">open -a "Google Chrome" --args --disable-web-security  
</code></pre>

<p>然后就可以看到下面的效果了：
<img src="/img/131012.jpg" alt="" /></p>

<p>Ubuntu Linux:</p>

<pre><code class="language-javascript">chromium-browser --disable-web-security  
</code></pre>

<p>windows</p>

<pre><code class="language-javascript">
chrome.exe --disable-web-security  
</code></pre>
<p>用命令行打开 Apple Safafi 方法是：</p>

<p>Mac OS 下：</p>

<p>open -a ‘/Applications/Safari.app’ –args –disable-web-security</p>

<p>Windows：</p>

<p>C:\Program Files\Safari\Safari.exe –disable-web-security</p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E7%90%86%E8%A7%A3HTML%E8%AF%AD%E4%B9%89%E5%8C%96/">
		        理解HTML语义化
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年09月19日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/Html/">Html</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>###什么是HTML语义化？</p>

<p>基本上都是围绕着几个主要的标签，像标题（H1~H6）、列表（li）、强调（strong em）等等.</p>

<p>可以概括为根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</p>

<p>###为什么要语义化？</p>

<ul>
  <li>
    <p>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；</p>
  </li>
  <li>
    <p>用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；</p>
  </li>
  <li>
    <p>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</p>
  </li>
  <li>
    <p>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</p>
  </li>
  <li>
    <p>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>
  </li>
</ul>

<p>###写HTML代码时应注意什么？</p>

<ul>
  <li>
    <p>尽可能少的使用无语义的标签div和span；</p>
  </li>
  <li>
    <p>在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</p>
  </li>
  <li>
    <p>不要使用纯样式标签，如：b、font、u等，改用css设置；</p>
  </li>
  <li>
    <p>需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</p>
  </li>
  <li>
    <p>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</p>
  </li>
  <li>
    <p>表单域要用fieldset标签包起来，并用legend标签说明表单的用途；</p>
  </li>
  <li>
    <p>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</p>
  </li>
</ul>

<p>HTML5新增了哪些语义标签，详述之。</p>

<p><a href="http://www.html5jscss.com/html5-semantics-section.html">见这位前端大拿的blog。</a></p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9BSEO/">
		        前端需要注意的一些SEO
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年07月28日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <ol>
  <li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可；</li>
  <li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页；</li>
  <li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取；</li>
  <li>重要内容不要用js输出：爬虫不会执行js获取内容；
少用iframe：搜索引擎不会抓取iframe中的内容；</li>
  <li>非装饰性图片必须加alt；</li>
  <li>提高网站速度：网站速度是搜索引擎排序的一个重要指标。</li>
</ol>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/JS%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83-CommonJS-AMD-CMD/">
		        JS中的模块规范(CommonJS，AMD，CMD)
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年06月10日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/javascript/">Javascript</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>如果你听过js模块化这个东西，那么你就应该听过或CommonJS或AMD甚至是CMD这些规范咯，我也听过，但之前也真的是听听而已。</p>

<p>现在就看看吧，这些规范到底是啥东西，干嘛的。</p>

<p>一、CommonJS</p>

<p>CommonJS就是为JS的表现来制定规范，因为js没有模块的功能所以CommonJS应运而生，它希望js可以在任何地方运行，不只是浏览器中。</p>

<p>CommonJS能有一定的影响力，我觉得绝对离不开Node的人气，不过喔，Node，CommonJS，浏览器甚至是W3C之间有什么关系呢，我找到了个贴切的图：</p>

<table>
  <tbody>
    <tr>
      <td>—————浏览器—– ——————</td>
      <td> </td>
      <td>————————–CommonJS———————————-</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>BOM</td>
      <td> </td>
      <td>DOM</td>
      <td> </td>
      <td>ECMAScript</td>
      <td> </td>
      <td>FS</td>
      <td> </td>
      <td>TCP</td>
      <td> </td>
      <td>Stream</td>
      <td> </td>
      <td>Buffer</td>
      <td> </td>
      <td>……..</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>——-W3C———–</td>
      <td> </td>
      <td>—————————————Node————————————————–</td>
    </tr>
  </tbody>
</table>

<p>CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}</p>

<p>require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。</p>

<p>比如说我们就可以这样用了：</p>

<p>复制代码
1 //sum.js
2 exports.sum = function(){…做加操作..};
3 
4 //calculate.js
5 var math = require(‘sum’);
6 exports.add = function(n){
7     return math.sum(val,n);
8 };
复制代码</p>

<p>虽说Node遵循CommonJS的规范，但是相比也是做了一些取舍，填了一些新东西的。</p>

<p>不过，说了CommonJS也说了Node，那么我觉得也得先了解下NPM了。NPM作为Node的包管理器，不是为了帮助Node解决依赖包的安装问题嘛，那它肯定也要遵循CommonJS规范啦，它遵循包规范（还是理论）的。</p>

<p>CommonJS WIKI讲了它的历史，还介绍了modules和packages等。</p>

<p>二、AMD</p>

<p>CommonJS是主要为了JS在后端的表现制定的，他是不适合前端的，为什么这么说呢？</p>

<p>这需要分析一下浏览器端的js和服务器端js都主要做了哪些事，有什么不同了：</p>

<table>
  <tbody>
    <tr>
      <td>—————————————服务器端JS</td>
      <td>浏览器端JS——————————————-</td>
    </tr>
  </tbody>
</table>

 				相同的代码需要多次执行  |    代码需要从一个服务器端分发到多个客户端执行

 				CPU和内存资源是瓶颈   |    带宽是瓶颈

 				加载时从磁盘中加载   |    加载时需要通过网络加载

<hr />

<p>于是乎，AMD(异步模块定义)出现了，它就主要为前端JS的表现制定规范。</p>

<p>AMD就只有一个接口：define(id?,dependencies?,factory);</p>

<p>它要在声明模块的时候制定所有的依赖(dep)，并且还要当做形参传到factory中，像这样：</p>

<pre><code class="language-js">define(['dep1','dep2'],function(dep1,dep2){...});
</code></pre>

<p>要是没什么依赖，就定义简单的模块，下面这样就可以啦：</p>

<pre><code class="language-js">define(function(){
    var exports = {};
    exports.method = function(){...};
    return exports; });
</code></pre>

<p>咦，这里有define，把东西包装起来啦，那Node实现中怎么没看到有define关键字呢，它也要把东西包装起来呀，其实吧，只是Node隐式包装了而已…..</p>

<p>RequireJS就是实现了AMD规范的呢。</p>

<p>这有AMD的WIKI中文版，讲了很多蛮详细的东西，用到的时候可以查看：AMD的WIKI中文版</p>

<p>三、CMD</p>

<p>大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版。</p>

<pre><code class="language-js">define(function(require,exports,module){...});
</code></pre>

<p>用过seajs吧，这个不陌生吧，对吧.</p>

<p>四、AMD与CMD的区别</p>

<p>CMD相当于按需加载，定义一个模块的时候不需要立即制定依赖模块，在需要的时候require就可以了，比较方便；而AMD则相反，定义模块的时候需要制定依赖模块，并以形参的方式引入factory中</p>

<pre><code class="language-js">//AMD方式定义模块
define(['dep1','dep2'],function(dep1,dep2){
     //内部只能使用制定的模块
      return function(){};
});
//CMD
define(function(require,exports,module){
   //此处如果需要某XX模块，可以引入
   var xx=require('XX');
});
</code></pre>

<p>而SEAJS也有use功能也是需要先引入所有依赖的模块，如</p>

<pre><code class="language-js">//SEAJS.Use方式
seajs.use(['dep1','dep2'],function(dep1,dep2){
     //这里实现事务
});
</code></pre>

<p>五、插件支持</p>

<p>但全球有两种比较流行的 JavaScript 模块化体系，一个是 Node 实现的 CommonJS，另外一个是 AMD。很多类库都同时支持 AMD 和 CommonJS，但是不支持 CMD。或许国内有很多 CMD 模块，但并没有在世界上流行起来。</p>

<p>现在比较火的 React 及周边类库，就是直接使用 CommonJS 的模块体系，使用 npm 管理模块，使用 Browserify 打包输出模块。</p>

<p>不久的将来 ES6 中新的模块化标准，可能就都得遵循新的标准了，什么AMD、CMD可能到时也不会怎么用了。</p>

<p>但是目前来说，前端开发没有用模块化编程就真的out的了，而目前的模块化编程，本人还是建议用SEAJS，虽然很多插件需要追加或修改一小块代码才能支持。但改过一次就能反复使用，也不会影响其它标准的支持。总体还算是比较方便实用的</p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E8%B0%88%E8%B0%88200-OK-(from-cache)-%E4%B8%8E-304-Not-Modified/">
		        谈谈200 OK (from cache) 与 304 Not Modified
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年04月27日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>为什么有的缓存是 200 OK (from cache)，有的缓存是 304 Not Modified 呢？很简单，看运维是否移除了 Entity Tag。移除了，就总是 200 OK (from cache)。没有移除，就两者交替出现。</p>

<p>其实， 200 OK (from cache)  是浏览器没有跟服务器确认，直接用了浏览器缓存；而 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。</p>

<p>它们都是在设置了缓存的情况下触发的。</p>

<p>那么，两者触发的时机有什么区别呢？200 OK (from cache) 是直接点击链接访问，输入网址按回车访问也能触发；而 304 Not Modified 是刷新页面时触发，或是设置了长缓存、但 Entity Tags 没有移除时触发。这是经过查阅资料得出的结论。博主实际测试了一下，结论与之相符：</p>

<p><img src="/img/post/1404271.jpg" alt="" /></p>

<p>直接访问有缓存的网站都触发 200 OK (from cache)</p>

<p><img src="/img/post/1404272.jpg" alt="" /></p>

<p>图2 – 刷新浏览器则会触发 304 Not Modifie</p>

<p><img src="/img/post/1404273.jpg" alt="" /></p>

<p>同一域名下，没有 Entity Tag 的资源直接访问，是 200 OK (from cache) 的结果</p>

<p><img src="/img/post/1404274.jpg" alt="" /></p>

<p>同一域名下，有 Entity Tag ，直接访问就会触发 304 Not Modified
现在一般都会设置长时间的缓存，正确设置方式参考这两篇笔记：</p>

<p><a href="https://www.bokeyy.com/post/high-performance-web-sites-rule3.html">如何正确设置 Expires Header 及其原理</a></p>

<p><a href="https://www.bokeyy.com/post/high-performance-web-sites-rule-13.html">如何正确移除 Entity Tags 及其原理</a></p>

<p>本文并不是说影响浏览器缓存只有 ETag 这一个因素的意思，请大家不要误解。只是就“为什么我加了缓存，有的却是 304 Not Modified， 而不是 200 OK(from cache)”这件事给出一个一针见血的原因和解答.</p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E8%BF%94%E5%9B%9E%E9%A1%B5%E9%9D%A2%E9%A1%B6%E9%83%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95-%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BD%BF%E7%94%A8zepto%E6%B2%A1%E6%9C%89%E6%BB%91%E5%8A%A8%E7%9A%84%E6%95%88%E6%9E%9C)/">
		        返回页面顶部的三种方法(解决移动端使用zepto没有滑动的效果)
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年03月15日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/zepto/">zepto</a>, <a href="/tags/html5/">html5</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>点击返回顶部，三种方法</p>

<p>1、这个方法jQuery使用正常，zepto使用没有动画</p>

<pre><code class="language-javascript">//zepto没有动画
$("body").animate({scrollTop: 0}, 500)
//zepto使用
$("body").scrollTop(0);

</code></pre>

<p>2、这个方法jQuery使用正常，zepto使用没有动画</p>

<pre><code class="language-javascript">window.scrollTo(0,0);
</code></pre>

<p>3、zepto使用可以有动画</p>

<pre><code class="language-javascript">function goTop(acceleration, time) {
acceleration = acceleration || 0.1;
time = time || 16;
var x1 = 0;
var y1 = 0;
var x2 = 0;
var y2 = 0;
var x3 = 0;
var y3 = 0;
if (document.documentElement) {
	x1 = document.documentElement.scrollLeft || 0;
	y1 = document.documentElement.scrollTop || 0;
}
if (document.body) {
	x2 = document.body.scrollLeft || 0;
	y2 = document.body.scrollTop || 0;
}
var x3 = window.scrollX || 0;
var y3 = window.scrollY || 0;
// 滚动条到页面顶部的水平距离
var x = Math.max(x1, Math.max(x2, x3));
// 滚动条到页面顶部的垂直距离
var y = Math.max(y1, Math.max(y2, y3));
// 滚动距离 = 目前距离 / 速度, 因为距离原来越小, 速度是大于 1 的数, 所以滚动距离会越来越小
var speed = 1 + acceleration;
window.scrollTo(Math.floor(x / speed), Math.floor(y / speed));
// 如果距离不为零, 继续调用迭代本函数
if (x &gt; 0 || y &gt; 0) {
	var invokeFunction = "goTop(" + acceleration + ", " + time + ")";
	window.setTimeout(invokeFunction, time);
}
}
$(".fix_go_top").on("click", function() {
    //$("body").scrollTop(0);
    //window.scrollTo(0,0);    goTop();
});
</code></pre>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E5%85%B3%E4%BA%8E%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/">
		        关于页面重绘和回流以及优化
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年03月3日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/Html/">Html</a>, <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>在讨论页面重绘、回流之前。需要对页面的呈现流程有些了解，页面是怎么把html结合css等显示到浏览器上的，下面的流程图显示了浏览器对页面的呈现的处理流程。可能不同的浏览器略微会有些不同。但基本上都是类似的。</p> <p><img src="/img/post/1403031.jpg" alt="" /></p> <p>1、 浏览器把获取到的HTML代码解析成1个DOM树，HTML中的每个tag都· 是DOM树中的1个节点，根节点就是我们常用的document对象。DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。</p> <p>2、 浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。</p> <p>3、DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree能识别样式，render tree中每个NODE都有自己的style，而且 render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。注意 visibility:hidden隐藏的元素还是会包含到 render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。根据CSS2的标准，render tree中的每个节点都称为Box (Box dimensions)，理解页面元素为一个具有填充、边距、边框和位置的盒子。</p> <p>4、 一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。</p> <p>回流与重绘</p> <p>1、 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。</p> <p>2、 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p> <p>注意：回流必将引起重绘，而重绘不一定会引起回流。</p> <p>回流何时发生：</p> <p>当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：</p> <p>1、添加或者删除可见的DOM元素；</p> <p>2、元素位置改变；</p> <p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p> <p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p> <p>5、页面渲染初始化；</p> <p>6、浏览器窗口尺寸改变——resize事件发生时；</p> <p>让我们看看下面的代码是如何影响回流和重绘的:</p> <pre><code class="language-javascript">var s = document.body.style; s.padding = "2px"; // 回流+重绘 s.border = "1px solid red"; // 再一次 回流+重绘 s.color = "blue"; // 再一次重绘 s.backgroundColor = "#ccc"; // 再一次 重绘 s.fontSize = "14px"; // 再一次 回流+重绘 // 添加node，再一次 回流+重绘 document.body.appendChild(document.createTextNode('abc!')); </code></pre> <p>说到这里大家都知道回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。</p> <p>聪明的浏览器</p> <p>从上个实例代码中可以看到几行简单的JS代码就引起了6次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句JS操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p> <p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：</p> <ol> <li> <p>offsetTop, offsetLeft, offsetWidth, offsetHeight</p> </li> <li> <p>scrollTop/Left/Width/Height</p> </li> <li> <p>clientTop/Left/Width/Height</p> </li> <li> <p>width,height</p> </li> <li> <p>请求了getComputedStyle(), 或者 IE的 currentStyle</p> </li> </ol> <p>当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。</p> <p><strong>如何减少回流、重绘</strong></p> <p>减少回流、重绘其实就是需要减少对render tree的操作（合并多次多DOM和样式的修改），并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有：</p> <p>1、直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）</p> <pre><code class="language-javascript">// 不好的写法 var left = 1; var top = 1; el.style.left = left + "px"; el.style.top = top + "px"; // 比较好的写法 el.className += " className1"; // 比较好的写法 el.style.cssText += "; left: " + left + "px; top: " + top + "px;"; </code></pre> <p>2、让要操作的元素进行”离线处理”，处理完后一起更新</p> <p>a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；</p> <p>b) 使用display:none技术，只引发两次回流和重绘；</p> <p>c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</p> <p>3、不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存</p> <pre><code class="language-javascript">// 别这样写，大哥 for(循环) { el.style.left = el.offsetLeft + 5 + "px"; el.style.top = el.offsetTop + 5 + "px"; } // 这样写好点 var left = el.offsetLeft, top = el.offsetTop, s = el.style; for (循环) { left += 10; top += 10; s.left = left + "px"; s.top = top + "px"; } </code></pre> <p>4、 让元素脱离动画流，减少回流的Render Tree的规模</p> <pre><code class="language-javascript">$("#block1").animate({left:50}); $("#block2").animate({marginLeft:50}); </code></pre> <p><strong>实例测试</strong></p> <p>最后用2个工具对上面的理论进行一些测试，分别是：dynaTrace(测试ie),Speed Tracer(测试Chrome)。</p> <p>第一个测试代码不改变元素的规则，大小，位置。只改变颜色，所以不存在回流，仅测试重绘，代码如下：</p> <pre><code class="language-javascript">&lt;body&gt; &lt;script type="text/javascript"&gt; var s = document.body.style; var computed; if (document.body.currentStyle) { computed = document.body.currentStyle; } else { computed = document.defaultView.getComputedStyle(document.body, ''); } function testOneByOne(){ s.color = 'red';; tmp = computed.backgroundColor; s.color = 'white'; tmp = computed.backgroundImage; s.color = 'green'; tmp = computed.backgroundAttachment; } function testAll() { s.color = 'yellow';...
		    <p>
		    <a class="text" href="/blog/%E5%85%B3%E4%BA%8E%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/zepto%E5%92%8Cjquery%E7%9A%84%E5%8C%BA%E5%88%AB-zepto%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BD%BF%E7%94%A88%E6%9D%A1%E5%B0%8F%E7%BB%93/">
		        zepto和jquery的区别，zepto的不同使用8条小结
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年02月11日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/Jquery/">Jquery</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>1、Zepto 对象 不能自定义事件.</p> <p>例如执行：</p> <pre><code class="language-javascript"> $({}).bind('cust', function(){}); </code></pre> <p>结果：</p> <p>TypeError: Object has no method ‘addEventListener’</p> <p>解决办法是创建一个脱离文档流的节点作为事件对象：</p> <p>例如：</p> <pre><code class="language-javascript">$('').bind('cust', function(){}); </code></pre> <p>2、 Zepto 的选择器表达式: [name=value] 中value 必须用 双引号 “ or 单引号 ‘ 括起来.</p> <p>例如执行：</p> <pre><code class="language-javascript">$('[data-userid=123123123]') </code></pre> <p>结果：Error: SyntaxError: DOM Exception</p> <p>解决办法:</p> <pre><code class="language-javascript">$('[data-userid="123123123]"') or $("[data-userid='123123123']") </code></pre> <p>2-1、zepto的选择器没有办法选出 $(“div[name!=’abc’]”) 的元素.</p> <p>2-2、zepto获取select元素的选中option不能用类似jq的方法$(‘option[selected]’),因为selected属性不是css的标准属性 应该使用.</p> <pre><code class="language-javascript"> ('option').not(function(){ return !this.selected }) </code></pre> <pre><code>比如：jq: </code></pre> <pre><code class="language-javascript"> $this.find('option[selected]').attr('data-v') * 1 </code></pre> <p>zepto:</p> <pre><code class="language-javascript">$this.find('option').not(function() {return !this.selected}).attr('data-v') * 1 </code></pre> <p>但是获取有select中含有disabled属性的元素可以用 $this.find(“option:not(:disabled)”) 因为disabled是标准属性 参考网址：https://github.com/madrobby/zepto/issues/503</p> <p>2-3、zepto在操作dom的selected和checked属性时尽量使用prop方法，以下是官方说明：</p> <p><img src="/img/post/140211.png" alt="" /></p> <p>3、Zepto 是根据标准浏览器写的，所以对于节点尺寸的方法只提供 width() 和 height()，省去了 innerWidth(), innerHeight(),outerWidth(),outerHeight() Zepto.js: 由盒模型（ box-sizing ）决定 jQuery: 忽略盒模型，始终返回内容区域的宽/高（不包含 padding 、 border ）解决方式就是使用 .css(‘width’) 而不是 .width() 。</p> <p>3-1、边框三角形宽高的获取. 假设用下面的 HTML 和 CSS 画了一个小三角形：</p> <pre><code class="language-html"> &lt;div class="caret"&gt;&lt;/div&gt; .caret { width: 0; height: 0; border-width: 0 20px 20px; border-color: transparent transparent blue; border-style: none dotted solid; } </code></pre> <p>jQuery 使用 .width() 和 .css(‘width’) 都返回 ，高度也一样； Zepto 使用 .width() 返回 ，使用 .css(‘width’) 返回 0px 。 所以，这种场景，jQuery 使用 .outerWidth() / .outerHeight() ；Zepto 使用 .width() / .height() 。</p> <p>3-2、offset() Zepto.js: 返回 top 、 left 、 width 、 height jQuery: 返回 width 、 height</p> <p>3-3、隐藏元素 Zepto.js: 无法获取宽高； jQuery: 可以获取。</p> <p>4、Zepto 的each 方法只能遍历 数组，不能遍历JSON对象.</p> <p>5、Zepto 的animate 方法参数说明 ：详情点击-&gt; zepto中animate的用法.</p> <p>6、zepto的jsonp callback函数名无法自定义.</p> <p>7、DOM 操作区别 jq代码：</p> <pre><code class="language-javascript"> (function($) { $(function() { var $list = $('&lt;ul&gt;&lt;li&gt;jQuery 插入&lt;/li&gt;&lt;/ul&gt;', { id: 'insert-by-jquery' }); $list.appendTo($('body')); }); })(window.jQuery); </code></pre> <p>jQuery 操作 ul 上的 id 不会被添加。 zepto代码</p> <pre><code class="language-javascript">Zepto(function($) { var $list = $('&lt;ul&gt;&lt;li&gt;Zepto 插入&lt;/li&gt;&lt;/ul&gt;', { id: 'insert-by-zepto' }); $list.appendTo($('body')); }); </code></pre> <p>Zepto 可以在 ul 上添加 id 。</p> <p>8、事件触发区别</p> <p>jq代码：</p> <pre><code class="language-javascript">(function($) { $(function() { $script = $('&lt;script /&gt;', { src: 'http://cdn.amazeui.org/amazeui/1.0.1/js/amazeui.min.js', id: 'ui-jquery' }); $script.appendTo($('body')); $script.on('load', function() { console.log('jQ script loaded'); }); }); })(window.jQuery); </code></pre> <p>使用 jQuery 时 load 事件的处理函数 不会 执行 zepto代码</p> <pre><code class="language-javascript">Zepto(function($) { $script = $('&lt;script /&gt;', { src: 'http://cdn.amazeui.org/amazeui/1.0.1/js/amazeui.js', id: 'ui-zepto' }); $script.appendTo($('body')); $script.on('load', function() { console.log('zepto script loaded');...
		    <p>
		    <a class="text" href="/blog/zepto%E5%92%8Cjquery%E7%9A%84%E5%8C%BA%E5%88%AB-zepto%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BD%BF%E7%94%A88%E6%9D%A1%E5%B0%8F%E7%BB%93/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/jQuery%E4%B8%AD.bind()-.live()%E5%92%8C.delegate()%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%88%AB/">
		        jQuery中.bind()、.live()和.delegate()之间区别
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年02月2日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/Jquery/">Jquery</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>要理清这三者的区别，我们先从实现到原理入手来看一下，首先看DOM树：</p>

<p>我们来可视化一个HMTL文档的DOM树是很有帮助的。一个简单的HTML页面看起来就像是这个样子：</p>

<p><img src="/img/post/1402021.jpg" alt="" /></p>

<p>事件冒泡(又称事件传播)
当我们点击一个链接时，其触发了链接元素的单击事件，该事件则引发任何我们已绑定到该元素的单击事件上的函数的执行。</p>

<pre><code class="language-javascript">
$('a').bind('click', function() { alert("That tickles!") });
</code></pre>
<p>因此一个单击操作会触发alert函数的执行。</p>

<p><img src="/img/post/1402022.jpg" alt="" /></p>

<p>click事件接着会向树的根方向传播，广播到父元素，然后接着是每个祖先元素，只要是它的某个后代元素上的单击事件被触发，事件就会传给它。</p>

<p><img src="/img/post/1402023.jpg" alt="" /></p>

<p>在操纵DOM的语境中，document是根节点。
___
现在我们可以较容易地说明.bind()、.live()和.delegate()的不同之处了。</p>

<p><strong><em>.bind()</em></strong></p>

<pre><code class="language-javascript">
$('a').bind('click', function() { alert("That tickles!") });
</code></pre>

<p>这是最简单的绑定方法了。JQuery扫描文档找出所有的$(‘a’)元素，并把alert函数绑定到每个元素的click事件上。</p>

<p><strong><em>.live()</em></strong></p>

<pre><code class="language-javascript">
$('a').live('click', function() { alert("That tickles!") });
</code></pre>

<p>JQuery把alert函数绑定到$(document)元素上，并使用’click’和’a’作为参数。任何时候只要有事件冒泡到document节点上，它就查看该事件是否是一个click事件，以及该事件的目标元素与’a’这一CSS选择器是否匹配，如果都是的话，则执行函数。
live方法还可以被绑定到具体的元素(或context)而不是document上，像这样：</p>

<pre><code class="language-javascript">$('a', $('#container')[0]).live(...);
</code></pre>

<p><strong><em>.delegate()</em></strong></p>

<pre><code class="language-javascript">
$('#container').delegate('a', 'click', function() { alert("That tickles!") });
</code></pre>
<p>JQuery扫描文档查找$(‘#container’)，并使用click事件和’a’这一CSS选择器作为参数把alert函数绑定到$(‘#container’)上。任何时候只要有事件冒泡到$(‘#container’)上，它就查看该事件是否是click事件，以及该事件的目标元素是否与CCS选择器相匹配。如果两种检查的结果都为真的话，它就执行函数。
可以注意到，这一过程与.live()类似，但是其把处理程序绑定到具体的元素而非document这一根上。精明的JS’er们可能会做出这样的结论，即$(‘a’).live() == $(document).delegate(‘a’)，是这样吗?嗯，不，不完全是。</p>

<hr />

<p>下面来看看我门为什么选择.live()或.delegate()而不是.bind()。毕竟，bind看起来似乎更加的明确和直接，难道不是吗?嗯，有两个原因让我们更愿意选择delegate或live而不是bind：</p>

<p>为了把处理程序附加到可能还未存在于DOM中的DOM元素之上。因为bind是直接把处理程序绑定到各个元素上，它不能把处理程序绑定到还未存在于页面中的元素之上。如果你运行了$(‘a’).bind(…)，而后新的链接经由AJAX加入到了页面中，则你的bind处理程序对于这些新加入的链接来说是无效的。</p>

<p>而另一方面live和delegate则是被绑定到另一个祖先节点上，因此其对于任何目前或是将来存在于该祖先元素之内的元素都是有效的。或者为了把处理程序附加到单个元素上或是一小组元素之上，监听后代元素上的事件而不是循环遍历并把同一个函数逐个附加到DOM中的100个元素上。把处理程序附加到一个(或是一小组)祖先元素上而不是直接把处理程序附加到页面中的所有元素上，这种做法带来了性能上的好处。</p>

<p><strong><em>停止传播</em></strong></p>

<p>最后一个我想做的提醒与事件传播有关。通常情况下，我们可以通过使用这样的事件方法来终止处理函数的执行：</p>

<pre><code class="language-javascript">　　
$('a').bind('click', function(e) { 
　　e.preventDefault(); 
　　// 或者 
　　e.stopPropagation(); 
　　});

</code></pre>

<p>不过，当我们使用live或是delegate方法的时候，处理函数实际上并没有在运行，需要等到事件冒泡到处理程序实际绑定的元素上时函数才会运行。而到此时为止，我们的其他的来自.bind()的处理函数早已运行了。</p>

<p><strong><em>为什么.delegate()要比.live()好用?</em></strong></p>

<p>基于几个原因，人们通常更愿意选用jQuery的delegate方法而不是live方法。考虑下面的例子：</p>

<pre><code class="language-javascript">
$('a').live('click', function() { blah() }); 
// 或者 
$(document).delegate('a', 'click', function() { blah() });

</code></pre>

<p><strong><em>速度</em></strong></p>

<p>后者要快过前者，因为前者首先要扫描整个的文档查找所有的$(‘a’)元素，把它们存成jQuery对象。尽管live函数仅需要把’a’作为串参数传递以用做之后的判断，但是$()函数并未知道被链接的方法将会是.live()。
而另一方面，delegate方法仅需要查找并存储$(document)元素。一种寻求避开这一问题的方法是调用在$(document).ready()之外绑定的live，这样它就会立即执行。在这种方式下，其会在DOM获得填充之前运行，因此就不会查找元素或是创建jQuery对象了。</p>

<p><strong><em>灵活性和链能力</em></strong></p>

<p>live函数也挺令人费解的。想想看，它被链到$(‘a’)对象集上，但其实际上是在$(document)对象上发生作用。由于这个原因，它能够试图以一种吓死人的方式来把方法链到自身上。实际上，我想说的是，以$.live(‘a’,…)这一形式作为一种全局性的jQuery方法，live方法会更具意义一些。</p>

<p><strong><em>仅支持CSS选择器</em></strong></p>

<p>最后一点，live方法有一个非常大的缺点，那就是它仅能针对直接的CSS选择器做操作，这使得它变得非常的不灵活。</p>


		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/IE6-IE7%E4%B8%8B-inline-block%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
		        IE6/IE7下：inline-block解决方案
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年01月20日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/IE/">IE</a>, <a href="/tags/兼容/">兼容</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>E6/IE7下对display:inline-block的支持性不好。比如在inline元素的display属性设置为inline-block时，所有的浏览器都支持；block元素的display属性设置为inline-block时，IE6/IE7浏览器是不支持的。</p>

<p>###产生的原因</p>

<p>虽然对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行，允许空格。（准确地说，应用此特性的元素现为内联对象，周围元素保持在同一行，但可以设置宽度和高度等块元素的属性）
IE中对内联元素使用display:inline-block，IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表征。从上面的这个分析，也不难理解为什么IE下，对块元素设置display:inline-block属性无法实现inline-block的效果。这时块元素仅仅是被display:inline-block触发了layout，而它本身就是行布局，所以触发后，块元素依然还是行布局，而不会如Opera中块元素呈递为内联对象。</p>

<p>###IE6下块元素如何实现display:inline-block的效果？</p>

<p>有两种方法：</p>

<p>1、先使用display:inline-block属性触发块元素，然后再定义display:inline，让块元素呈递为内联对象（两个display 要先后放在两个CSS声明中才有效果，这是IE的一个经典bug，如果先定义了display:inline-block，然后再将display设回 inline或block，layout不会消失）。代码如下（…为省略的其他属性内容）：</p>

<pre><code class="language-css">
div {display:inline-block;...} 
div {display:inline;}
</code></pre>

<p>2、直接让块元素设置为内联对象呈递（设置属性display:inline），然后触发块元素的layout（如：zoom:1 或float属性等）。代码如下：</p>

<pre><code class="language-css">div { display:inline-block; _zoom:1;_display:inline;} /*推荐*/
div { display:inline-block; _zoom:1;*display:inline;} /*推荐:IE67*/
</code></pre>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%86%9F%E7%9F%A5%E7%9A%84Meta-http-equiv%E5%B1%9E%E6%80%A7/">
		        不为人熟知的Meta http-equiv属性
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年01月10日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/Html/">Html</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 
meat标签的http-equiv属性语法格式是：＜meta http-equiv=”参数” content=”参数变量值”＞ ；其中http-equiv属性主要有以下几种参数：</p>

<p>1、Expires(期限) 
说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 
用法：</p>

<pre><code class="language-html">
&lt;meta http-equiv="expires" content="Wed, 20 Jun 2007 22:33:00 GMT"&gt;
</code></pre>
<p>注意：必须使用GMT的时间格式。</p>

<p>2、Pragma(cache模式) 
说明：是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出 
用法：</p>

<pre><code class="language-html">&lt; meta http-equiv="Pragma" content="no-cache"&gt;
</code></pre>
<p>注意：这样设定，访问者将无法脱机浏览。</p>

<p>3、Refresh(刷新) 
说明：自动刷新并指向新页面。 
用法：</p>

<pre><code class="language-html">&lt;meta http-equiv="Refresh" content="2；URL=http://www.net.cn/"&gt;  
</code></pre>
<p>注意：其中的2是指停留2秒钟后自动刷新到URL网址。</p>

<p>4、Set-Cookie(cookie设定) 
说明：如果网页过期，那么存盘的cookie将被删除。 
用法：</p>

<pre><code class="language-html">&lt;meta http-equiv="Set-Cookie" content="cookievalue=xxx;expires=Wednesday, 20-Jun-2007 22:33:00 GMT； path=/"&gt;
</code></pre>
<p>注意：必须使用GMT的时间格式。</p>

<p>5、Window-target(显示窗口的设定) 
说明：强制页面在当前窗口以独立页面显示。 
用法：</p>

<pre><code class="language-html">&lt;meta http-equiv="Window-target" content="_top"&gt; 
</code></pre>
<p>注意：用来防止别人在框架里调用自己的页面。</p>

<p>6、content-Type(显示字符集的设定) 
说明：设定页面使用的字符集。 
用法：</p>

<pre><code class="language-html">&lt;meta http-equiv="content-Type" contect="text/html; charset=gb2312"&gt; 
</code></pre>

<p>7、Pics-label(网页等级评定)</p>

<pre><code class="language-html">&lt;meta http-equiv="Pics-label" contect=""&gt;  
</code></pre>
<p>说明：在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的。</p>

<p>8、Page_Enter、Page_Exit 
设定进入页面时的特殊效果</p>

<pre><code class="language-html">&lt;meta http-equiv="Page-Enter"    contect="revealTrans(duration=1.0,transtion=12)"&gt;    
</code></pre>
<p>设定离开页面时的特殊效果</p>

<pre><code class="language-html">&lt;meta http-equiv="Page-Exit"    contect="revealTrans(duration=1.0,transtion=12)"&gt;  
</code></pre>

<p>Duration的值为网页动态过渡的时间，单位为秒。<br />
Transition是过渡方式，它的值为0到23，分别对应24种过渡方式。如下表：<br />
0    盒状收缩    1    盒状放射<br />
2    圆形收缩    3    圆形放射<br />
4    由下往上    5    由上往下<br />
6    从左至右    7    从右至左<br />
8    垂直百叶窗    9    水平百叶窗<br />
10    水平格状百叶窗    11垂直格状百叶窗<br />
12    随意溶解    13从左右两端向中间展开<br />
14从中间向左右两端展开    15从上下两端向中间展开<br />
16从中间向上下两端展开    17    从右上角向左下角展开<br />
18    从右下角向左上角展开    19    从左上角向右下角展开<br />
20    从左下角向右上角展开    21    水平线状展开<br />
22    垂直线状展开    23    随机产生一种过渡方式</p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/HTTP-%E5%A4%B4%E6%8E%A7%E5%88%B6%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8Aheader%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/">
		        HTTP 头控制缓存以及header常用指令及配置方式
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年01月7日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>网页的缓存是由HTTP消息头中的“Cache-control”来控制的，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。其作用根据不同的重新浏览方式分为以下几种情况：</p> <ol> <li> <p>打开新窗口 值为private、no-cache、must-revalidate，那么打开新窗口访问时都会重新访问服务器。 而如果指定了max-age值，那么在此值内的时间里就不会重新访问服务器，例如： Cache-control: max-age=5(表示当访问此网页后的5秒内再次访问不会去服务器)</p> </li> <li> <p>在地址栏回车 值为private或must-revalidate则只有第一次访问时会访问服务器，以后就不再访问。 值为no-cache，那么每次都会访问。 值为max-age，则在过期之前不会重复访问。</p> </li> <li> <p>按后退按扭 值为private、must-revalidate、max-age，则不会重访问， 值为no-cache，则每次都重复访问</p> </li> <li> <p>按刷新按扭 　 无论为何值，都会重复访问</p> </li> </ol> <p>Cache-control值为“no-cache”时，访问此页面不会在Internet临时文章夹留下页面备份。</p> <p>另外，通过指定“Expires”值也会影响到缓存。例如，指定Expires值为一个早已过去的时间，那么访问此网时若重复在地址栏按回车，那么每次都会重复访问： Expires: Fri, 31 Dec 1999 16:00:00 GMT</p> <p>比如：禁止页面在IE中缓存</p> <p>http响应消息头部设置：</p> <p>CacheControl = no-cache Pragma=no-cache Expires = -1</p> <p>Expires是个好东东，如果服务器上的网页经常变化，就把它设置为-1，表示立即过期。如果一个网页每天凌晨1点更新，可以把Expires设置为第二天的凌晨1点。</p> <p>当HTTP1.1服务器指定CacheControl = no-cache时，浏览器就不会缓存该网页。</p> <p>旧式 HTTP 1.0 服务器不能使用 Cache-Control 标题。 所以为了向后兼容 HTTP 1.0 服务器，IE使用Pragma:no-cache 标题对 HTTP 提供特殊支持。 如果客户端通过安全连接 (https://)/与服务器通讯，且服务器在响应中返回 Pragma:no-cache 标题， 则 Internet Explorer不会缓存此响应。注意：Pragma:no-cache 仅当在安全连接中使用时才防止缓存，如果在非安全页中使用，处理方式与 Expires:-1相同，该页将被缓存，但被标记为立即过期。</p> <hr /> <p>header常用指令</p> <p>header分为三部分：</p> <p>第一部分为HTTP协议的版本(HTTP-Version)； 第二部分为状态代码(Status)； 第三部分为原因短语(Reason-Phrase)。</p> <p>// fix 404 pages: 用这个header指令来解决URL重写产生的404 header header(‘HTTP/1.1 200 OK’);</p> <p>// set 404 header: 页面没找到 header(‘HTTP/1.1 404 Not Found’);</p> <p>//页面永久重定向，可以告诉搜索引擎更新它们的urls // set Moved Permanently header (good for redrictions) // use with location header header(‘HTTP/1.1 301 Moved Permanently’);</p> <p>// 访问受限 header(‘HTTP/1.1 403 Forbidden’);</p> <p>// 服务器错误 header(‘HTTP/1.1 500 Internal Server Error’);</p> <p>// 重定向到一个新的位置 // redirect to a new location: header(‘Location: http://www.sina.com.cn);</p> <p>延迟一段时间后重定向 // redrict with delay: header(‘Refresh: 10; url=http://www.sina.com.cn’); print ‘You will be redirected in 10 seconds’;</p> <p>// 覆盖 X-Powered-By value // override X-Powered-By: PHP: header(‘X-Powered-By: PHP/4.4.0’); header(‘X-Powered-By: Brain/0.6b’);</p> <p>// 内容语言 (en = English) // content language (en = English) header(‘Content-language: en’);</p> <p>//最后修改时间(在缓存的时候可以用到) // last modified (good for caching) $time = time() - 60; // or filemtime($fn), etc header(‘Last-Modified: ‘.gmdate(‘D, d M Y H:i:s’, $time).’ GMT’);</p> <p>// 告诉浏览器要获取的内容还没有更新 // header for telling the browser that the content // did not get changed header(‘HTTP/1.1 304 Not Modified’);</p> <p>// 设置内容的长度 (缓存的时候可以用到): // set content length (good for caching): header(‘Content-Length: 1234’);</p> <p>// 用来下载文件: // Headers for an download: header(‘Content-Type: application/octet-stream’); header(‘Content-Disposition: attachment; filename=”example.zip”’); header(‘Content-Transfer-Encoding: binary’);</p> <p>// 禁止缓存当前文档: // load the file to send:readfile(‘example.zip’); // Disable caching of the current document: header(‘Cache-Control: no-cache, no-store, max-age=0, must-revalidate’); header(‘Expires: Mon, 26 Jul 1997 05:00:00 GMT’);</p> <p>// 设置内容类型: // Date in the pastheader(‘Pragma: no-cache’); // set content type: header(‘Content-Type: text/html; charset=iso-8859-1’); header(‘Content-Type: text/html; charset=utf-8’);</p> <p>// plain text file header(‘Content-Type: text/plain’);</p> <p>// JPG picture...
		    <p>
		    <a class="text" href="/blog/HTTP-%E5%A4%B4%E6%8E%A7%E5%88%B6%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8Aheader%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/HTML5%E5%9C%A8%E8%B7%A8%E5%9F%9F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%97%B6%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83/">
		        HTML5在跨域消息发送时的安全性相关问题思考
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2014年01月5日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/html5/">html5</a>, <a href="/tags/安全/">安全</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>因为最近的项目要求，逐步开始关注web安全性方面的内容,加之最近又做了两个h5的项目，遇到了一些跨域方面的问题，今天就来说说html5在跨域消息发送上到安全问题。
在h5之前，由于同源策略的限制导致在两个窗口之间进行消息传送必须是使用相同的协议、端口和主机。而H5有了一种新的方法叫做postMessage()，通过这一方法，跨域的消息传送将不再受到同源策略的限制。
postMessage()使用方式：
在发送方：</p>

<pre><code class="language-javascript">otherWindeow.postMessage(message,targetOrigin,[transfer]);
</code></pre>
<p><strong>参数说明</strong>：</p>

<p>Otherwindows：涉及到的其他窗口</p>

<p>Message：被发送到接收窗口的信息</p>

<p>targetOrigin：接收窗口必须规定的URL。如果没有任何特殊偏好，可以将其规定为“<em>”定义“</em>”为targetOrigin，但这样做其实会存在一些安全隐患，在后文中我会提到。</p>

<p>Transfer：这个是任意的。</p>

<p>接收方：</p>

<p>当otherWindow.postMessage()执行时，消息将会被发送到接收方的窗口。</p>

<p>接收方使用以下这段代码后，我们就可以接收到这条消息。</p>

<pre><code class="language-javascript">window.addEventListener("message",receiveMessage,false);
function receiveMessage(event){
  if(event.origin !=="http://site.com:8383"){
    return;
    //
    ...
  }
}
</code></pre>

<p>通过该段代码，我们可以访问数据以及这一信息的源。如下所示：</p>

<p>Event.origin：提供信息的源(我们所接收到的信息的URL)</p>

<p>Event.data：提供实际所发送出的信息内容</p>

<hr />

<p>###安全性实例分析</p>

<p>出于演示需要，设立了如下两个服务：</p>

<p>A: http://localhost:8383/</p>

<p>B: http://localhost/</p>

<p>上面两个URL具有不同的端口，第一个运行在8383端口，第二个则是在80端口。我们通过端口不同来模拟跨域的情况。</p>

<p>A是发送窗口，B是接收窗口
现在我们加载第二个URL(http://localhost/ )作为第一个URL的iframe：</p>

<p><img src="/img/post/1401051.png" alt="" /></p>

<p>通过使用postMessage()的方法，我可以轻松的将消息从第一个URL发送到第二个URL.</p>

<p>我们可以通过点击”send message“的按钮来进行验证。</p>

<p><img src="/img/post/1401052.png" alt="" /></p>

<p>尽管加载在第一个URL中的iframe与其并不同源，但通过postMessage() 即可进行信息传递。</p>

<p>现在我们来看一些postMessage()使用过程中可导致应用出现漏洞的例子：</p>

<p><strong>case1</strong></p>

<p>发送方代码：</p>

<pre><code class="language-javascript">
receiver.postMessage('Hi,There...!','*');
</code></pre>

<p>当发送者把targetOrigin规定为通配符”*“时，将会导致未知的信息被陌生的接收方(窗口)接收到。原因是从接收窗口传来的消息任何人都可以再加载一个iframe来进行监听。因此在进行敏感数据的传输时，使用通配符是一个十分错误的决定。</p>

<p>针对此问题最好的解决方法就是在发送时添加具体的目标字段，如下所示：</p>

<pre><code class="language-javascript">
receiver.postMessage('Hi,There...!','http://localhost');
</code></pre>
<p><strong>case2</strong>
接收窗口代码：</p>

<pre><code class="language-javascript">
function receiver(e){
  do something..!
}
</code></pre>

<p>在上面这段代码中可以看到，我们是直接接收发送方的消息对其进行处理，并不检验是否来自发送方。</p>

<p>但检查消息的来源无疑是十分重要的，这样可以防止消息来自未经授权的发送者。</p>

<p>因此，我们只需要在代码中加入对发送方的验证，这一问题就可解决了。代码如下：</p>

<pre><code class="language-javascript">
function receiver(e){
  if (e.origin!=="http://localhost:8383"){
    return;
  }
  ...
  do something ...!;
}

</code></pre>
<p>通过检验event.origin，来进行验证。</p>

<p><strong><em>Case3</em></strong></p>

<p>在这一过程中，发送方和接收方都应该验证正在传送的.消息。如果数据插入到HTML DOM中时并没有进行验证，那么应用很有可能遭受到基于DOM的跨站脚本攻击。</p>

<p>由下面这段代码可以看出，当应用程序接收到攻击者发来的恶意信息，并已经插入到HTML DOM使用innerHTML属性时，其显得异常脆弱。</p>

<p>发送方：</p>

<pre><code class="language-javascript">receiver.postMessage("&lt; img src="x" onerror=alert(1);&gt;",'http://localhost');

}
</code></pre>
<p>接收方：</p>

<pre><code class="language-javascript">
function receiver(e){
  if (e.origin!=="http://localhost:8383"){
    return;
  }
  ...
  messageEle.innerHTML = "Message from localhost:8383: "+e.data;
}
</code></pre>

<p>执行上面这段代码，可导致在接收窗口出现XSS。</p>

<p><img src="/img/post/1401053.png" alt="" /></p>

<p>解决这一问题最简单的方法就是在给元素分配数据值时使用 textContent 而不是innerHTML.</p>

<p>如下所示：</p>

<p>发送方：</p>

<pre><code class="language-javascript">receiver.postMessage("&lt; img src="x" onerror=alert(1);&gt;",'http://localhost');

}
</code></pre>
<p>接收方：</p>

<pre><code class="language-javascript">
function receiver(e){
  if (e.origin!=="http://localhost:8383"){
    return;
  }
  ...
  element.textContent = "Message from localhost:8383: "+e.data;
}
</code></pre>
<p>执行上面这段代码时我们可以看到，文本中显示frame是作为数据而不是代码。</p>

<p><img src="/img/post/1401054.png" alt="" /></p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/CSS-%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84-7%E7%A7%8D%E6%96%B9%E6%B3%95/">
		        CSS 元素垂直居中的 7种方法
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2013年12月15日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/css/">css</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>利用CSS进行元素的水平居中，比较简单，行级元素设置其父元素的text-align center，块级元素设置其本身的left 和 right margins为auto即可。本文收集了六种利用css进行元素的垂直居中的方法，每一种适用于不同的情况，在实际的使用过程中选择某一种方法即可。</p> <p>方法1 ： IE 10 以下不兼容 transform:</p> <pre><code class="language-html"> &lt;style&gt; /*声明伸缩容器*/ #parent {position: relative;background-color: red;width: 220px;height: 200px;} #child { position: absolute; top: 50%; left: 50%; z-index: 3; height:30%; width:50%; -webkit-transform: translate(-50%,-50%); /*margin: -15% 0 0 -25%;*/ background-color: #fff; } &lt;/style&gt; &lt;body&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt;Content here&lt;/div&gt; </code></pre> <hr /> <p>方法2: FLEX BOX 弹性布局 IE10以下不适用</p> <pre><code class="language-html"> &lt;style&gt; /*声明伸缩容器*/ #parent { display:-webkit-flex;; justify-content:center; align-items:center; background-color: red;width: 220px;height: 200px;} .child { flex:1; border: #999999 solid 1px; background-color: #fff; } &lt;/style&gt; &lt;body&gt; &lt;div id="parent"&gt; &lt;div class="child"&gt;Content here&lt;/div&gt;&lt;div class="child"&gt;Content here&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; </code></pre> <hr /> <p>方法3:Line-Height Method</p> <p><img src="/img/post/1312151.jpg" alt="" /></p> <p>适用：单行文本垂直居中</p> <p>html</p> <pre><code class="language-html"> &lt;div id="parent"&gt;&lt;div id="child"&gt;Text here&lt;/div&gt;&lt;/div&gt; </code></pre> <p>css</p> <pre><code class="language-css"> #child {line-height: 200px;} </code></pre> <hr /> <p>垂直居中一张图片，代码如下</p> <pre><code class="language-html"> &lt;div id="parent"&gt;&lt;img src="image.png" alt="" /&gt;&lt;/div&gt; ```css #parent {line-height: 200px;}#parent img {vertical-align: middle;} </code></pre> <p>适用：通用</p> <p>代码：</p> <pre><code class="language-html"> &lt;div id="parent"&gt;&lt;div id="child"&gt;Content here&lt;/div&gt;&lt;/div&gt; </code></pre> <pre><code class="language-css">#parent {display: table;}#child {display: table-cell;vertical-align: middle;} </code></pre> <p>低版本 IE fix bug：</p> <pre><code class="language-css">#child {display: inline-block;} </code></pre> <hr /> <p>方法4: CSS Table Method</p> <p><img src="/img/post/1312152.jpg" alt="" /></p> <p>适用：通用</p> <p>代码：</p> <pre><code class="language-html">&lt;div id="parent"&gt;&lt;div id="child"&gt;Content here&lt;/div&gt;&lt;/div&gt; </code></pre> <pre><code class="language-css">#parent {display: table;}#child {display: table-cell;vertical-align: middle;} </code></pre> <p>低版本 IE fix bug：</p> <pre><code class="language-css">#child {display: inline-block;} </code></pre> <hr /> <p>方法4:Absolute Positioning and Negative Margin</p> <p><img src="/img/post/1312153.jpg" alt="" /></p> <p>适用：块级元素</p> <p>代码：</p> <pre><code class="language-html"> &lt;div id="parent"&gt;&lt;div id="child"&gt;Content here&lt;/div&gt;&lt;/div&gt; </code></pre> <pre><code class="language-css"> #parent {position: relative;}#child {position: absolute;top: 50%;left: 50%;height: 30%;width: 50%;margin: -15% 0 0 -25%;} </code></pre> <hr /> <p>方法5:Absolute Positioning and Stretching <img src="/img/post/1312154.jpg" alt="" /></p> <p>适用：通用，但在IE版本低于7时不能正常工作</p> <p>代码：</p> <pre><code class="language-html"> &lt;div id="parent"&gt;&lt;div id="child"&gt;Content here&lt;/div&gt;&lt;/div&gt; </code></pre> <pre><code class="language-css">#parent {position: relative;}#child {position: absolute;top: 0;bottom: 0;left: 0;right: 0;width: 50%;height: 30%;margin: auto;} </code></pre> <hr /> <p>方法6:Equal Top and Bottom Padding <img src="/img/post/1312155.jpg" alt="" /></p> <p>适用：通用，demo</p> <p>代码：</p> <pre><code class="language-html"> &lt;div id="parent"&gt;&lt;div id="child"&gt;Content here&lt;/div&gt;&lt;/div&gt; </code></pre> <pre><code class="language-css"> #parent {padding: 5% 0;}#child {padding: 10% 0;} </code></pre> <hr /> <p>方法7:Floater Div</p> <p><img...
		    <p>
		    <a class="text" href="/blog/CSS-%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84-7%E7%A7%8D%E6%96%B9%E6%B3%95/">
		      Continue Reading...
		    </a>
		    </p>
		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/padding-ie-%E4%B8%8D%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/">
		        padding ie 不兼容问题
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2013年11月10日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/IE/">IE</a>, <a href="/tags/兼容/">兼容</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>在使用padding时，在ie 兼容时通常我们遇到3种情况：</p>

<ul>
  <li>IE6 正常 IE7/FF不正常</li>
</ul>

<p>这种情况下我们这样处理：</p>

<pre><code class="language-html">   padding: 7px !important;（针对FF/IE7）
   padding: 6px;（针对IE6）
</code></pre>

<ul>
  <li>IE6 IE7正常 FF不正常</li>
</ul>

<p>这种情况我们要这么处理，因为!important IE7也是能识别的！</p>

<pre><code class="language-html">
  padding: 7px;（针对FF）
 *padding: 6px;（针对IE6/IE7）
</code></pre>
<ul>
  <li>E6 IE7 FF都不一样
```</li>
</ul>

<p>这种情况我们这样来处理：</p>

<pre><code class="language-html">   padding: 7px;（针对FF）
  *padding: 6px;（针对IE7）
  _padding: 5px; （针对IE6）
</code></pre>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8BCSS3-webkit-font-smoothing-%E5%B1%9E%E6%80%A7/">
		        高性能网站建设指南读书笔记之CSS3 -webkit-font-smoothing 属性
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2013年11月7日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/css/">css</a>, <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>CSS3里面加入了一个“-webkit-font-smoothing”属性。这个属性可以使页面上的字体抗锯齿,使用后字体看起来会更清晰舒服。加上之后就顿时感觉页面小清晰了。</p>

<p>在测试中将 -webkit-font-smoothing设置为none，非常模糊。</p>

<p>将-webkit-font-smoothing设置为antialiased，变得非常平滑，效果非常不错。</p>

<p>其默认可以支持6个值（如图），暂时我能看到效果的就是三个：
none | subpixel-antialiased | antialiased
其他的三个，我设置了，好像没什么变化。大家可以自己在控制台调试看看。</p>

<p><img src="/img/post/1312193.jpg" alt="" /></p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8BCSS-Sprites/">
		        高性能网站建设指南读书笔记之CSS Sprites
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2013年11月4日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/css/">css</a>, <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>大名鼎鼎的CSS Sprites。今天来总结一下：</p>

<p>CSS Sprites简介</p>

<p>通常被意译为“CSS图像拼合”或“CSS贴图定位”。CSS Sprites并不是一门新技术，目前它已经在网页开发中发展得较为成熟，一些较为成熟的网站的网页中到处都可发现css sprites 的影子。但CSS Sprites并不是什么金科玉律，但在很多情况下，它有着一定的优势，最重要的是它可以减轻服务器的负载，提高网页加载速度。随着Web设计向着精致、 巧妙的方向发展，设计师们开始考虑使用非Javascript的方式制作鼠标滑过、悬停菜单的效果，这时CSS Sprite应运而生。</p>

<p><strong>说白了，CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。</strong></p>

<p>当页面加载时，不是加载每个单独图片，而是一次加载整个组合图片。这是一个了不起的改进，它大大减少了HTTP请求的次数，减轻服务器压力，同时缩短了悬停加载图片所需要的时间延迟，使效果更流畅，不会停顿。</p>

<hr />
<p>CSS Sprites优点</p>

<p>CSS Sprites为什么突然跑火，跟能够提升网站性能有关。显而易见，这是它的巨大优点之一。</p>

<p>利用CSS Sprites能很好地减少了网页的http请求，从而大大的提高了页面的性能，这是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；
个人认为CSS Sprites能减少图片的字节，我曾经比较过多次3张图片合并成1张图片的字节总是小于这3张图片的字节总和。
CSS Sprites缺点</p>

<p>诚然CSS Sprites是如此的强大，但是也存在一些不可忽视的缺点。</p>

<p>在图片合并的时候，你要把多张图片有序的合理的合并成一张图片，还要留好只够的空间，防止板块内不会出现不必要的背景，否则可能会出现出现干扰图片的情况；这些还好，做痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂；
CSS Sprites在开发的时候比较麻烦，你要通过photoshop或其他工具测量计算每一个背景单元的精确位置，这是针线活，没什么难度，但是很繁琐；不过网上已经有高手开发出“CSS Sprites 样式生成工具”，大家可以尝试一下。
CSS Sprites在维护的时候比较麻烦，sprites是一般双刃剑，如果页面背景有少许改动，一般就要改这张合并的图片，无需改的地方最好不要动，这样避 免改动更多的css，如果在原来的地方放不下，有只能（最好）往下加图片，这样图片的字节就增加了，因为每次的图片改动都得往这个图片删除或添加内容，显 得稍微繁琐，而且重新算图片的位置（尤其是这种上千px的图）也是一件颇为不爽的事情。当然，在性能的口号下，这些都是可以克服的。
由于图片的位置需要固定为某个绝对数值，这就失去了诸如center之类的灵活性。
___</p>

<p>CSS Sprites总结</p>

<p>性能压倒一切。CSS Sprites非常值得学习和应用，特别是页面有一堆ico（图标）。总之很多时候大家要权衡一下利弊，在决定是不是应用CSS Sprites。为保持兼容性和维护性，sprites图片中的各个部分保持一定的距离是一种不错的做法。</p>

<hr />
<p>书中示例：</p>

<pre><code class="language-html">
   &lt;style&gt; #navbar span { width:31px; height:31px; display:inline; float:left; background-image:url(/images/spritebg.gif?t=1442038329); } .home { background-position:0 0; margin-right:4px; margin-left: 4px;} .gifts { background-position:-32px 0; margin-right:4px;} .cart { background-position:-64px 0; margin-right:4px;} .settings { background-position:-96px 0; margin-right:4px;} .help { background-position:-128px 0; margin-right:0px;} 
   &lt;/style&gt; 

   &lt;div id="navbar" style="background-color: #F4F5EB; border: 2px ridge #333; width: 180px; height: 32px; padding: 4px 0 4px 0;"&gt; 
      &lt;a href="javascript:alert('Home')" title="Home"&gt;&lt;span class="home"&gt;&lt;/span&gt;&lt;/a&gt;
      &lt;a href="javascript:alert('Gifts')" title="Gifts"&gt;&lt;span class="gifts"&gt;&lt;/span&gt;&lt;/a&gt; 
      &lt;a href="javascript:alert('Cart')" title="Cart"&gt;&lt;span class="cart"&gt;&lt;/span&gt;&lt;/a&gt; 
      &lt;a href="javascript:alert('Settings')" title="Settings"&gt;&lt;span class="settings"&gt;&lt;/span&gt;&lt;/a&gt;      &lt;a href="javascript:alert('Help')" title="Help"&gt;&lt;span class="help"&gt;&lt;/span&gt;&lt;/a&gt; 
    &lt;/div&gt;
</code></pre>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9B%BE%E5%9C%A8CSS%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">
		        高性能网站建设指南读书笔记之图片地图在CSS中的使用
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2013年11月3日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/css/">css</a>, <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>最近看了《 High Performance Web Site》，书上对网站性能优化方面从多个角度做了剖析，本文就总结一下书中css优化方面涉及到的图片地图在CSS中的使用。</p>

<p>在HTML中还可以把图片划分成多个热点区域，每一个热点域链接到不同网页的资源。这种效果的实质是把一幅图片划分为不同的热点区域，再让不同的区域进行 超链接。这就是影像地图。要完成地图区域超链接要用到三种标签：&lt; img&gt;&lt; map&gt;&lt; area&gt;下面分别介绍这些 标签的用法：</p>

<p>影像地图（Image Map）标签的使用格式：</p>

<pre><code class="language-html">
    &lt;img src="图形文件名" usemap="#图的名称"&gt;

      &lt;!-- 插入图片时要在&lt;img&gt;标记中设置参数usemap="#图的名称" ismap，以表示对图像地图（图的名称）的引用；--&gt;

    &lt;map name="图的名称"&gt;

       &lt;!--用&lt;map&gt;标记设定图像地图的作用区域，并用name属性爲图像起一个名字--&gt;

     &lt;area shape=形状 coords=区域座标列表 href="URL资源地址"&gt;

     ......可根据需要定义多少个热点区域

     &lt;area shape=形状 coords=区域座标列表 href="URL资源地址"&gt;

    &lt;/map&gt;

</code></pre>
<hr />
<p>提示和注释：</p>

<p>注释：area 元素永远嵌套在 map 元素内部。area 元素可定义图像映射中的区域。</p>

<p>注释：&lt; img&gt;中的 usemap 属性可引用 &lt; map&gt; 中的 id 或 name 属性（取决于浏览器），所以我们应同时向 &lt; map&gt; 添加 id 和 name 属性。</p>

<pre><code class="language-html">
&lt;img src="planets.jpg" border="0" usemap="#planetmap" alt="Planets" /&gt;

&lt;map name="planetmap" id="planetmap"&gt;
  &lt;area shape="circle" coords="180,139,14" href ="venus.html" alt="Venus" /&gt;
  &lt;area shape="circle" coords="129,161,10" href ="mercur.html" alt="Mercury" /&gt;
  &lt;area shape="rect" coords="0,0,110,260" href ="sun.html" alt="Sun" /&gt;
&lt;/map&gt;

</code></pre>

<p><a href="http://stevesouders.com/hpws/imagemap.php">点我看示例</a></p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/css-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/">
		        css 原理及其优化
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2013年10月26日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/css/">css</a>, <a href="/tags/性能优化/">性能优化</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>在写css代码时 做一些简单的优化，这样css的渲染速率会有一定的提高的。</p>

<p>###浏览器是如何渲染页面和加载页面</p>

<p>为什么有些网站打开的时候会加载会很慢，而且是整个页面同时显示的，而有些网站是从顶到下逐步显示出来的？要搞懂这个可以先从下面这个常规流程开始：</p>

<ul>
  <li>
    <p>浏览器下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。</p>
  </li>
  <li>
    <p>在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完）。</p>
  </li>
  <li>
    <p>如果遇到语义解释性的标签嵌入文件（JS脚本，CSS样式），那么此时IE的下载过程会启用单独连接进行下载。</p>
  </li>
  <li>
    <p>并且在下载后进行解析，解析过程中，停止页面所有往下元素的下载。</p>
  </li>
  <li>
    <p>样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前已经渲染的）重新进行渲染。</p>
  </li>
  <li>
    <p>JS、CSS中如有重定义，后定义函数将覆盖前定义函数。</p>
  </li>
  <li>
    <p>这里关键的是第2-5这三点。渲染效率与下面三点有关：</p>

    <ul>
      <li>
        <p>css选择器的查询定位效率</p>
      </li>
      <li>
        <p>浏览器的渲染模式和算法</p>
      </li>
      <li>
        <p>要进行渲染内容的大小</p>
      </li>
    </ul>
  </li>
</ul>

<p>###什么是CSS以及CSS的优点</p>

<p>什么是CascadingStyleSheets（层叠样式表）</p>

<ul>
  <li>CSS是CascadingStyleSheets(层叠样式表)的简称.</li>
  <li>CSS 语言是一种标记语言,它不需要编译,可以直接由浏览器解释执行(属于浏览器解释型语言).</li>
  <li>在标准网页设计中CSS负责网页内容 (XHTML)的表 现.</li>
  <li>CSS文件也可以说是一个文本文件,它包含了一些CSS标记,CSS文件必须使用css为文件名后缀.</li>
  <li>可以通过简单的更改 CSS文件,改变网页 的整体表现形式,可以减少我们的工作量,所以她是每一个网页设计人员的必修课.</li>
  <li>CSS是由W3C的CSS工作组产生和维护的.</li>
</ul>

<p><strong><em>采用CSS+DIV进行网页重构相对与传统的TABLE网页布局而具有以下3个显著优势：</em></strong></p>

<ul>
  <li>
    <p>表现和内容相分离将设计部分剥离出来放在一个独立样式文件中，HTML文件中只存放文本信息。这样的页面对搜索引擎更加友好。</p>
  </li>
  <li>
    <p>提高页面浏览速度对于同一个页面视觉效果，采用CSS+DIV重构的页面容量要比TABLE编码的页面文件容量小得多，前者一般只有后者的1/2大小。浏览器就不用去编译大量冗长的标签。</p>
  </li>
  <li>
    <p>易于维护和改版你只要简单的修改几个CSS文件就可以重新设计整个网站的页面。</p>
  </li>
</ul>

<p><strong><em>浏览器对CSS的匹配原理</em></strong></p>

<p>浏览器CSS匹配是从右到左进行查找。比如之前说的DIV#divBoxpspan.red{color:red;}，浏览器的查找顺序如下：先查找html中所有class=’red’的span元素，找到后，再查找其父辈元素中是否有p元素，再判断p的父元素中是否有id为 divBox的div元素，如果都存在则CSS匹配上。</p>

<p>浏览器从右到左进行查找的好处是为了尽早过滤掉一些无关的样式规则和元素。firefox称这种查 找方式为keyselector(关键字查询)，所谓的关键字就是样式规则中最后(最右边)的规则，上面的key就是span.red。</p>

<p>###优化你的CSS</p>

<ul>
  <li>css 命名 、书写规范；（好的代码看上去就很整齐 很有条理性这样方便日后的维护和管理）。</li>
  <li>
    <p>css优先级； 选择器权重：内联样式：1000，id选择器：1000， class选择器：10，标签选择器：1  注意权重的问题。</p>
  </li>
  <li>
    <p>少用滤镜，少用hack，少用position：absolute。</p>
  </li>
  <li>
    <p>多用继承属性。</p>
  </li>
  <li>
    <p>使用简写样式：例如margin: 10px; 浏览器会解释为上下左右各有10px的外补丁。margin： 0 10px 浏览器解析为 左右有10px的外补丁。</p>
  </li>
  <li>
    <p>不要在ID选择器和class选择器前 使用标签名 例如：div.box { color: #f00; }; 直接 可以 用类名， .box { color:#f00;}  这样浏览器找到这个class后 就不用再匹配是否存在div标签.从而提高了渲染效率。当然同一级的 有不同的样式可以这样写，但是不建议这样。</p>
  </li>
  <li>
    <p>css的层级关系不要太深 用class直接代替多余的层级元素。例如 .box .box-con .box-list li { line-height: 24px; } 这么长。。。增加代码量减小开发效率。刚也说了，css渲染是从上到下，从右到左的
所以直接这样写就可以了.box-list li { line-height: 24px; };</p>
  </li>
  <li>
    <p>平铺背景图片不要过小，影响渲染速率。</p>
  </li>
  <li>float使用要谨慎。</li>
  <li>
    <p>合理化布局（模块化布局）；可以把样式划分为 基类 和扩展类 ;模块化布局 ：模块基本相同的样式写在 基类里，不同的在重新用class来定义称为扩展类 。</p>
  </li>
  <li>在css渲染效率中id和class的效率是基本相当的</li>
</ul>

<p>class最在第一次载入中被缓存，在层叠中会有更加好的效果，在根部元素采用id会具有更加好（id有微妙的速度优势）。</p>


		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E7%94%A8jQuery%E4%B8%8EJSONP%E8%BD%BB%E6%9D%BE%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98/">
		        用jQuery与JSONP轻松解决跨域访问的问题
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2013年09月27日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/Jquery/">Jquery</a>, <a href="/tags/跨域/">跨域</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>跨域的安全限制都是指浏览器端来说的.服务器端是不存在跨域安全限制的,所以通过本机服务器端通过类似httpclient方式完成“跨域访问”的 工作，然后在浏览器端用AJAX获取本机服务器端“跨域访问”对应的url.来间接完成跨域访问也是可以的.但很显然开发量比较大,但限制也最少,很多 widget开放平台server端(如sohu博客开放平台)其实就么搞的.不在本次讨论范围.</p>

<p>我们要讨论的是浏览器端的真正跨域访问,推荐的是目前jQuery $.ajax()支持get方式的跨域,这其实是采用jsonp的方式来完成的.</p>

<p>真实案例:</p>

<pre><code class="language-javascript">
var qsData = {'searchWord':$("#searchWord").attr("value"),'currentUserId':$("#currentUserId").attr("value"),'conditionBean.pageSize':$("#pageSize").attr("value")};
$.ajax({
   async:false,
   url: http:/ /跨域的dns/document!searchJSONResult.action,
   type: "GET",
   dataType: 'jsonp',
   jsonp: 'jsoncallback',
   data: qsData,
   timeout: 5000,
   beforeSend: function(){
   //jsonp 方式此方法不被触发.原因可能是dataType如果指定为jsonp的话,就已经不是ajax事件了
   },
   success: function (json) {
   //客户端jquery预先定义好的callback函数,成功获取跨域服务器上的json数据后,会动态执行这个callback函数
	    if(json.actionErrors.length!=0){
	        alert(json.actionErrors);
	    }
	    genDynamicContent(qsData,type,json);
   },
   complete: function(XMLHttpRequest, textStatus){
   $.unblockUI({ fadeOut: 10 });
   },
   error: function(xhr){
    //jsonp 方式此方法不被触发.原因可能是dataType如果指定为jsonp的话,就已经不是ajax事件了
    //请求出错处理
    alert("请求出错(请检查相关度网络状况.)");
   }
});


</code></pre>

<p>注意:</p>

<pre><code class="language-javascript">
$.getJSON(" http://跨域的dns/document!searchJSONResult.action?name1="+value1+"&amp;jsoncallback=?",
function(json){
if(json.属性名==值){
// 执行代码
    }
});
</code></pre>

<p>这种方式其实是上例$.ajax({..}) api的一种高级封装,有些$.ajax api底层的参数就被封装而不可见了.
这样,jquery就会拼装成如下的url get请求</p>

<p>http:/ / 跨域的 dns/document!searchJSONResult.action?&amp;jsoncallback=jsonp1236827957501&amp;_=1236828192549&amp;searchWord=%E7%94%A8%E4%BE%8B¤tUserId=5351&amp;conditionBean.pageSize=15</p>

<p>在响应端(http://跨域的dns/document!searchJSONResult.action),
通过 jsoncallback = request.getParameter(“jsoncallback”) 得到jquery端随后要回调的js function name:jsonp1236827957501
然后 response的内容为一个Script Tags:”jsonp1236827957501(“+按请求参数生成的json数组+”)”;
jquery就会通过回调方法动态加载调用这个js tag:jsonp1236827957501(json数组);
这样就达到了跨域数据交换的目的.</p>

<p>jsonp的最基本的原理是:动态添加一个script标签，而script标签的src属性是没有跨域的限制的。这样说来,这种跨域方式其实与ajax XmlHttpRequest协议无关了.
这样其实”jQuery AJAX跨域问题”就成了个伪命题了,jquery $.ajax方法名有误导人之嫌.</p>

<p>如果设为dataType: ‘jsonp’, 这个$.ajax方法就和ajax XmlHttpRequest没什么关系了,取而代之的则是JSONP协议.</p>

<p>JSONP是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问JSONP即JSON with Padding。由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源。如果要进行跨域请求，我们可以通过使用 html的script标记来进行跨域请求，并在响应中返回要执行的script代码，其中可以直接使用JSON传递javascript对象。这种跨域 的通讯方式称为JSONP。</p>

<p>jsonCallback 函数jsonp1236827957501(….): 是浏览器客户端注册的，获取跨域服务器上的json数据后，回调的函数.</p>

<ul>
  <li>Jsonp原理：</li>
</ul>

<p>首先在客户端注册一个callback (如:’jsoncallback’), 然后把callback的名字(如:jsonp1236827957501)传给服务器。注意：服务端得到callback的数值后，要用 jsonp1236827957501(……)把将要输出的json内容包括起来，此时，服务器生成 json 数据才能被客户端正确接收。</p>

<p>然后以 javascript 语法的方式，生成一个function , function 名字就是传递上来的参数 ‘jsoncallback’的值 jsonp1236827957501 .</p>

<p>最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。</p>

<p>客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时javascript文档数据,作为参数，
传入到了客户端预先定义好的 callback 函数(如上例中jquery $.ajax()方法封装的的success: function (json))里.（动态执行回调函数）</p>

<p>可以说jsonp的方式原理上和&lt; script src=”http://跨域/…xx.js”&gt; &lt;\/ script&gt;是一致的(qq空间就是大量采用这种方式来实现跨域数据交换 的) .JSONP是一种脚本注入(Script Injection)行为,所以也有一定的安全隐患.</p>

<p>原理的示例代码:</p>

<pre><code class="language-javascript">
//客户端的JAVASCRIPT代码
var script=document.createElement("script");
script.src="http://www.pl4cj.com:8888/5/6/action.php?param=123&amp;callback="+fnName;
document.getElementsByTagName("head")[0].appendChild(script)

//服务器端的PHP代码，一定要有callback来进行回调，在这里加上括号，是让它以语句块的方式来进行解析
</code></pre>

<pre><code class="language-php">
&lt;?php
&lt;SPAN style="COLOR: #ff00ff"&gt;echo $_GET["callback"]."(".json_encode($_GET).");";
&lt;/SPAN&gt;?
</code></pre>

<p><strong>注意,jquey是不支持post方式跨域的</strong>
为什么呢?
虽然采用post +动态生成iframe是可以达到post跨域的目的,但这样做是一个比较极端的方式,不建议采用.
也可以说get方式的跨域是合法的,post方式从安全角度上,被认为是不合法的, 万不得已还是不要剑走偏锋..</p>

<p>client端跨域访问的需求看来也引起w3c的注意了,看资料说html5 WebSocket标准支持跨域的数据交换,应该也是一个将来可选的跨域数据交换的解决方案。</p>


		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/%E8%A7%A3%E5%86%B3IE6%E7%9A%84PNG%E9%80%8F%E6%98%8EJS%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">
		        解决IE6的PNG透明JS插件使用介绍
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2013年09月25日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tags"></i>: <a href="/tags/IE/">IE</a>, <a href="/tags/兼容/">兼容</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <p>IE6的PNG透明是个老问题了，最近有朋友问我有没有最好的解决这个问题的插件。虽然知道且在用DD_belatedPNG这个插件，今天抽空把这个发上来。</p>

<p>虽然之前在原博客里发过一款jquery的png插件，但是不支持背景平铺。 
DD_belatedPNG使用了微软的VML语言对PNG图片进行重新绘制，以达到半透明的效果，并且能支持background-position和background-repeat属性，支持伪类。是一款不错的值得推荐的插件，用法也比较简单。</p>

<p>使用方法：</p>

<pre><code class="language-html">
&lt;!--[if IE 6]&gt; 
&lt;script src="DD_belatedPNG.js"&gt;&lt;/script&gt; 
&lt;script&gt; 
DD_belatedPNG.fix('.png_bg'); 
&lt;/script&gt; 
&lt;![endif]--&gt; 

</code></pre>

<p>引用函数是DD_belatedPNG.fix()，括号里的 .png_bg 改成你的css选择器名称。</p>

<ul>
  <li>ID选择器例子：</li>
</ul>

<pre><code class="language-javascript">DD_belatedPNG.fix('#png'); 
</code></pre>

<ul>
  <li>伪类例子：</li>
</ul>

<pre><code class="language-javascript">DD_belatedPNG.fix('.png a:hover,.png a:focus'); 
</code></pre>

<ul>
  <li>img标签例子：</li>
</ul>

<pre><code class="language-javascript">DD_belatedPNG.fix('img'); 
</code></pre>

<p>如果是多个直接加逗号（英文下的）就行。例如：</p>

<pre><code class="language-javascript">
DD_belatedPNG.fix('.png_bg,#png,.png a:hover,.png a:focus,img'); 
</code></pre>

<p>使用方法：</p>

<pre><code class="language-html">
&lt;!--[if IE 6]&gt; 
&lt;script type="text/javascript" src="js/dd_png.js"&gt;&lt;/script&gt; 
&lt;script type="text/javascript"&gt; 
DD_belatedPNG.fix('.tel,.head_content'); 
&lt;/script&gt; 
&lt;![endif]--&gt; 
</code></pre>

<p>括号里的是样式选择器，中间用逗号隔开.</p>

<p>JS文件下载地址:
<a href="http://xiazai.jb51.net/201304/yuanma/DD_belatedPNG_jb51net.rar">0.0.8a-min.js (压缩版)</a></p>

		  
		  </div>
		</div>
        
            
	

				
		<div class="post-teaser">
		  <header>
		    <h1>
            <a id="post-link-trans" class="post-link" href="/blog/CSS%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%AB/">
		        CSS样式的优先级别
		      </a>
		    </h1>
		    <p id="subtitletrans" class="subtitlecontainer">
		      <a class="subtitle">2013年09月20日</a>
		       | <a class="subtitle" href="/About/">cyan</a>
		       | <a class="subtitle">  <i class="fa fa-book"></i>: <a href="/前端/">前端</a></a> <a class="subtitle">  <i class="fa fa-tag"></i>: <a href="/tags/css/">css</a></a>
		    </p>
		  </header>
		  <div class="excerpt">
		  
		  
		    <ul>
  <li>优先原则一：文本从上到下，后出现的样式优先于前面出现的同一样式</li>
</ul>

<p>例：</p>

<pre><code class="language-html">
&lt;style type="text/css"&gt;
.def1{background:black;}
.def2{background:yellow; }
&lt;/style&gt;

&lt;div class="def2 def1"&gt;测试1&lt;/div&gt;
</code></pre>

<p>结果：所有浏览器均yellow色，注意：与class=”” 引号内的顺序无关，只看.def1和.def2在声明时的顺序，.def2后声明的所以权重高。
___</p>
<ul>
  <li>优先原则二：id声明（即 # 开头的样式）&gt; class声明（即 . 开头的样式）&gt; 标签声明(即 类似 div 开头)</li>
</ul>

<p>以上三种声明处于不同的量级，份量上，div 开头相当于 1克 重，. 开头相当于 1公斤 重，# 开头相当于 1吨 重。</p>

<p>例：</p>

<pre><code class="language-html">
&lt;style type="text/css"&gt;
#bb{background:pink}
.def{background:black;}
div{background:yellow; }
&lt;/style&gt;

&lt;div id="bb" class="def"&gt;测试2&lt;/div&gt;
</code></pre>

<p>结果：所有浏览器均pink色，注意：虽然按优先原则一，后出现的权重高，但那只是在同样重量级下的比较，优先原则二各重量级别就不同了。
___</p>
<ul>
  <li>优先原则三：数量取胜。如果同一个样式声明即一个大括号{}由多个 # . 或 div 组成，则权重按出现符号的量级增加</li>
</ul>

<p>比如：#bb #tt #dd {background:red} 则重量等于3吨,</p>

<p>#bb .tt ul.dd li {background:red} 则重量等于1吨2公斤2克，这么精确的重量，就不需要举例了吧。</p>

<p>####再次说明：优先原则一只适用两个样式声明同样重的情况.
___</p>
<ul>
  <li>优先原则四：‘!important’。相当于无限重量，在之前已经有说明，需要注意：ie下，在同一条样式声明即一个大括号中出现的!important 会被随后出现的同名样式冲洗掉。</li>
</ul>

<pre><code class="language-html">&lt;style type="text/css"&gt;
.def1{background:yellow !important;background:red;}
.def2{background:green;}
&lt;/style&gt;

&lt;div class="def1 def2"&gt;dd&lt;/div&gt;
</code></pre>

<p>结果：ie下，green色，background:yellow !important被后面的background:red冲洗了，而background:red与background:green的较量中，前者败在优先原则一之下
___</p>
<ul>
  <li>优先原则五：近水楼台</li>
</ul>

<pre><code class="language-html">&lt;div style="background:black"&gt;&lt;/div&gt;
</code></pre>
<p>直接写在元素体内的style优先级别最高！（仅次于!important）用重量来形容，可以定为百万吨量级。</p>

<pre><code class="language-html">&lt;style type="text/css"&gt;
.def1{ background:red;}
&lt;/style&gt;

&lt;div class="def1 " style="background:black"&gt;dd&lt;/div&gt;
</code></pre>

<p>结果：black色。</p>

<pre><code class="language-html">&lt;style type="text/css"&gt;
.def1{ background:red !important;}
&lt;/style&gt;

&lt;div class="def1 " style="background:black"&gt;dd&lt;/div&gt;
</code></pre>

<p>结果：red色。</p>

<pre><code class="language-html">&lt;style type="text/css"&gt;
.def1{ background:red !important;}
&lt;/style&gt;

&lt;div class="def1 " style="background:black !important"&gt;dd&lt;/div&gt;
</code></pre>

<p>结果：black色。</p>


		  
		  </div>
		</div>
        

    
</div>
</div>

    		</div> <!-- #et-main-area -->
		</div> <!-- #page-container -->
		
<script src="/js/katex_init.js"></script>



<footer id="page-footer-trans" class="page-footer">
	<!--<p class="text"><a href="https://cyan24.github.io">Cyan的技术笔记</a> 
</p>-->
	Copyright &copy; 2017 <a href="https://cyan24.github.io">Cyan的技术笔记</a> 
 All Rights Reserved. 
	<p class="text">Hosted by <a href="https://github.com">GitHub</a><a alt="Fork me on GitHub" href="https://github.com/cyan24">Fork me on GitHub</a></p>
</footer>


    
<!-- WP Audio player plugin v1.9.3 - https://www.tipsandtricks-hq.com/wordpress-audio-music-player-plugin-4556/ -->
    <script type="text/javascript">
        soundManager.useFlashBlock = true; // optional - if used, required flashblock.css
        soundManager.url = '/plugins/soundmanager2.swf';
        function play_mp3(flg, ids, mp3url, volume, loops)
        {
            //Check the file URL parameter value
            var pieces = mp3url.split("|");
            if (pieces.length > 1) {//We have got an .ogg file too
                mp3file = pieces[0];
                oggfile = pieces[1];
                //set the file URL to be an array with the mp3 and ogg file
                mp3url = new Array(mp3file, oggfile);
            }

            soundManager.createSound({
                id: 'btnplay_' + ids,
                volume: volume,
                url: mp3url
            });

            if (flg == 'play') {
                    soundManager.play('btnplay_' + ids, {
                    onfinish: function() {
                        if (loops == 'true') {
                            loopSound('btnplay_' + ids);
                        }
                        else {
                            document.getElementById('btnplay_' + ids).style.display = 'inline';
                            document.getElementById('btnstop_' + ids).style.display = 'none';
                        }
                    }
                });
            }
            else if (flg == 'stop') {
    //soundManager.stop('btnplay_'+ids);
                soundManager.pause('btnplay_' + ids);
            }
        }
        function show_hide(flag, ids)
        {
            if (flag == 'play') {
                document.getElementById('btnplay_' + ids).style.display = 'none';
                document.getElementById('btnstop_' + ids).style.display = 'inline';
            }
            else if (flag == 'stop') {
                document.getElementById('btnplay_' + ids).style.display = 'inline';
                document.getElementById('btnstop_' + ids).style.display = 'none';
            }
        }
        function loopSound(soundID)
        {
            window.setTimeout(function() {
                soundManager.play(soundID, {onfinish: function() {
                        loopSound(soundID);
                    }});
            }, 1);
        }
        function stop_all_tracks()
        {
            soundManager.stopAll();
            var inputs = document.getElementsByTagName("input");
            for (var i = 0; i < inputs.length; i++) {
                if (inputs[i].id.indexOf("btnplay_") == 0) {
                    inputs[i].style.display = 'inline';//Toggle the play button
                }
                if (inputs[i].id.indexOf("btnstop_") == 0) {
                    inputs[i].style.display = 'none';//Hide the stop button
                }
            }
        }
    </script>
    <script type='text/javascript' src="/js/frontend-builder-global-functions.js"></script>
<script type='text/javascript' src="/js/custom.js"></script>
<script type='text/javascript' src="/js/jquery.fitvids.js"></script>
<script type='text/javascript' src="/js/waypoints.min.js"></script>
<script type='text/javascript' src="/js/jquery.magnific-popup.js"></script>
<script type='text/javascript'>
/* <![CDATA[ */
var et_custom = {"ajaxurl":"http:\/\/blog.ibireme.com\/wp-admin\/admin-ajax.php","images_uri":"http:\/\/blog.ibireme.com\/wp-content\/themes\/Divi\/images","builder_images_uri":"http:\/\/blog.ibireme.com\/wp-content\/themes\/Divi\/includes\/builder\/images","et_load_nonce":"ae39988568","subscription_failed":"Please, check the fields below to make sure you entered the correct information.","fill":"Fill","field":"field","invalid":"Invalid email","captcha":"Captcha","prev":"Prev","previous":"\u4e0a\u4e00\u9875","next":"\u4e0b\u4e00\u9875","is_builder_plugin_used":""};
/* ]]> */
</script>
<script type='text/javascript' src="/js/frontend-builder-scripts.js"></script>
  </body>
</html>
