<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cyan的技术笔记</title>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>Cyan的技术笔记</description>
    <pubDate>Mon, 18 Sep 2017 12:53:13 +0800</pubDate>
    
      <item>
        <title>2017上海 前端开发者大会小记</title>
        <link>http://localhost:4000/blog/2017%E4%B8%8A%E6%B5%B7-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%E5%B0%8F%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2017%E4%B8%8A%E6%B5%B7-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%E5%B0%8F%E8%AE%B0/</guid>
        <description>&lt;p&gt;前几日有幸参加了前端开发者大会，本次大会包括有业界的阿里巴巴、百度、美团、京东、360、58等知名公司的前端技术负责人或资深专家都有参参与分享相关业内一些新动态，本篇小记主要是记录和回顾vue作者尤雨溪带来的关于vue的相关分享，部分内容来自于小佑（尤雨溪）的现场ppt内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/17041501.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;vue-2017现状与展望&quot;&gt;Vue 2017现状与展望&lt;/h2&gt;

&lt;p&gt;首先Vue开始做到现在已经差不多三个年了，从最初是非常小的个人项目，到今天的规模，其本身的定位也是在发生着变化，最早发布vue的时候，初衷是做Just  a  view  layer  library，所以叫Vue。做着做着后来发现本身一方面我本身在自己用的过程中也会需要用到各种各样的库，另一方面,作者发现如果确实你只提供一个核心，对于一些早期用户体验是很好，他们本身喜欢自己去细细的控制整个栈的每个部分。如果想要面向更广大的用户，一个琐碎的生态系统反而会导致一些生产力上有负面影响，所以会加一些框架都会包含的东西，比如像路由、状况管理等等，今天Vue的定位演变成渐进式框架，Vue的生态系统有提供完全的前端框架，并不是强迫你要用Vue一定要用所有的全家桶。如果可以只用Vue本身，不需要一下子把所有东西都用上。关于渐进式框架这个理念，就是把整个前端栈涵盖的事情，比如说组建系统、路由、状态管理等一层层区分之后，会有分层，如果只用Vue核心只包含了最左边的红圈的东西。这个策略还是比较成功的，确实大幅度降低了框架的进入门槛，使得Vue迅速获得了很多用户。
&lt;img src=&quot;/img/post/17041502.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ember提出，针对不同的应用复杂度，选择不同的工具复杂度里面。今天Vue的增长，在去年一直到现在，相当迅猛，马上要突破5万，在所有项目里面排第12。NPM上每月近50万次下载，CHROME开发者插件有14.6万周活跃用户。国内使用的用户非常多，前段时间做了一个调查，这只是列出了大家知道的公司，大厂很多产品在用，也有还没上市的独角兽，也有小的新锐创业公司，总的来说在国内使用的增长还是非常可观。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/17041503.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/17041504.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/17041505.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;去年Vue2.0发布到现在，Vue经历了技术上新的变化，去年9月底发布了2.0，从头重写但是保留了决大部分API。引入了Flow类型检查，提高代码健壮性。基于virtual  dom的渲染机制，更轻、更快，获得跨平台渲染能力。还有官方Typescript支持。
&lt;img src=&quot;/img/post/17041506.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Vue2.0里面最大的变化，就是底层渲染机制,Vue2.0依然是使用模板，有一个把模板编译到渲染函数的过程，首先这个架构能让vue支持模板和手写函数，会有一些用户来说更偏向渲染函数，能够给他们用真正的程序语言进行表达的灵活性。但是模板在实际生产环境中也是有相当的固定优势，首先更适合用来思考界面本身的结构和样式之间的关联性，更好的体现你界面的语义结果，渲染函数最后就变成一堆代码。&lt;/p&gt;

&lt;p&gt;模板对设计师和对写样式的开发者有更好的亲和。Vue2.0两边都有，所以会有一个模板编译过程，链接里面的应用，左边是模板，右边是编译后的函数。两种编译模式，一种是运行时，一种是构建时，你直接把模板写在页面里面，Vue在页面加载之后，把模板编译成渲染函数。构建时渲染是打包发布的同时把原文件的模板处理运行时就不需要再编译一遍了。
&lt;img src=&quot;/img/post/17041507.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;vue是两段式编译策略，运行时基于with的简易编译器，构建时额外一次编译去掉with。编译器可剥离：构建时模板编译不需要在运行时包含编译器，可减少将近8kb gzip。
&lt;img src=&quot;/img/post/17041508.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.0的服务端渲染，流式渲染：充分利用Node和HTTP对Streaming的支持。&lt;/p&gt;

&lt;p&gt;组建级缓存，大幅度提升抗压能力，引入一个概念bundlerenderer：解决同构代码在服务端的构建和部署。bundlerenderer的优点：避免跨请求状况污染；除了入口文件和构建配置外，业务代码完全同构；服务端包和服务端代码解耦，便于部署，甚至可以热部署。&lt;/p&gt;

&lt;p&gt;整个架构对于业务代码是零侵入性的，打包起来部署的时候是分的很清楚。整个服务端的包就是一个文件，使得你前端构建流程和后端部署完全解耦。你的服务端服务器都不需要充气进程，文件更新，重建渲染器实例就完成了，都是传统的不具备的。&lt;/p&gt;

&lt;p&gt;2016年11月就发布了2.0主要引入的应用就是ScopedSlots，传递一个可复用的模板片断给子组件。组件内部可以把传进来的组件内容，嵌入到组件自身里面，内容再组构的机制。可复用的模板片断可以获得子组件传回来的数据。&lt;/p&gt;

&lt;p&gt;ScopedSlots还有很多有意思的用法，可以写这样一个组件。传进去一个模板，模板会获得一个参数。可以根据传回来的参数根据不同的状态，还在等待请求还是请求发生错误，渲染不同的内容。这个组件就把HTTP过程完全抽象掉了，你甚至不需要在JS里面引一个库，处理回调，根据回调的状况异步的处理应用的状态。ScopedSlots有很多很有意思的用法可以发觉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/17041509.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/post/17041510.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;12月发布了Vuex  2.1。Vuex  Namespaced  Modules：带命名空间的模块可以包含自己的state，actions，mutations和getters，就像一个小的store。通过它们可以轻松的对业务逻辑进行分块封装，最后只需要在Root store入口处组合。甚至可以通过动态模块注册来配合代码分割/懒加载。&lt;/p&gt;

&lt;p&gt;2017年1月5号发布Vue.devtoots3.0。做了大量的UI细节改进，配合Weex进行快照的查看，可以看过去派发的每一个对应的状态。
&lt;img src=&quot;/img/post/17041511.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2017年2月26号发布了2.2，vue引入了服务端渲染改进。配合Webpack，完美支持路由级别的代码懒加载（对业务代码无侵入性）。Vue-Style-loader自动抽取Critical  css；bundlernderer支持Source  Map。&lt;/p&gt;

&lt;p&gt;要提高首屏加载速度，就是保证首屏永远只加载真正需要的资源，相关的东西尽量只加载渲染首屏需要的资源，可能有10个不同的Vue，如果渲染一个Vue的时候就把其它10个Vue一起加载显然是不效率的，理想情况是每个Vue都分割成单独的代码块，每次只需要渲染对应Vue的代码。&lt;/p&gt;

&lt;p&gt;对于CSS也有代码分割的需求，传统的服务端渲染的时候，有一个问题，如果用内嵌形式的CSS会有一个问题，会有短暂的时间没有样式，显然是不理想的。现在可以避免首屏无样式的问题，也可以确保CSS跟随业务代码被分割出去的。&lt;/p&gt;

&lt;p&gt;2.2内置了Chrome  timeline性能追踪支持。更完成了异常处理，生命周期钩子里面出现错误不再crash整个应用。同时推出renderError：当渲染出错提供fallback组件。那个组件错了，立马可以知道哪个组件错了，不需要看数据函的信息。
&lt;img src=&quot;/img/post/17041512.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.3在服务端的渲染做了改进，为了提供最完美的服务端渲染的首屏的性能，存在代码分割的情况下，通过分析Webpack服务端和客户端的构建信息，自动推导需要在客户端与加载的文件，生成最优的&lt;script&gt;和&amp;lt;link rel=“preload/prefetch”&amp;gt;链接。&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;同时还做了一些其他优化，自动选用不包含CSS字符串的异步JS文件，避免Critical  CSS被两次下载。比如在JavaScript有一个字符串是CSS，才指出的HTML里面也有字符船，等于字符串被重复了两次，我们会把每次割出去的代码包打两份，一份有CSS，一份没有CSS，避免首屏双重加载CSS的问题。&lt;/p&gt;

&lt;p&gt;2.3还有异步组件改进，在没有服务端没有渲染的情况下，你异步请求一个组件会有什么问题呢，会有网络延时，加载错误等等。我们会进行这些问题的处理。这些都是用户体验上的小优化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/17041513.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.3里面使用函数式组件不需要显示声明props，父组件添加的V-on会以ctx.listeners体现。&lt;/p&gt;

&lt;p&gt;2.3的其它改进：有passive事件侦听：@touchmove.passive。.sync将会以prop+listener语法糖的形式回归。&lt;/p&gt;

&lt;p&gt;2.3发布之后可能会提供官方测试的工具库，同时会准备重构官方CLI模板，让用户在更新的时候，有版本控制的更新，模板方面有官方的服务端渲染模板，PWA、Weex等模板。&lt;/p&gt;

&lt;p&gt;2.0发布之后差不多半年了多了，社区涌现出了一批优秀的组件框架，相当不一般已经相当成熟了，Element  UI、iView 、Muse-UI这三个已经非常成熟了，包括Vue  Material、Vuetify等等，社区涌现了非常成熟的框架.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/17041514.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/17041515.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2017年展望：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;更好的TypeScript整合：TypeScript团队为Vue量身打造更好的类型类型推导。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;单文件组件CSS改进»&amp;gt;和：：slotted选择器，CSS  variable  theming。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;SSR性能进一步优化。然后Vuex与Rx怎么进行更好的整合。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们会有一个基于Proxy的响应式系统重构，最大的优点是我们不需要Vue.set，同时会应用到lazy  observation，只转化我们启动的时候用到的部分，之后用到的之后再转，避免Vue文件过于庞大，基于这个可以支持显示构建响应式对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;谷歌在起草新的标准  HTML  Modules：类似单文件组件的新标准。
他们起草过程中，跟作者有过一些沟通，他们最理想的情况就是以后Vue的单文件组件，稍做修改就可以做原生的HTML  Modules在浏览器使用，可能还需要两到三年的时间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sat, 15 Apr 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>2016上海 iWeb 峰会小记</title>
        <link>http://localhost:4000/blog/2016%E4%B8%8A%E6%B5%B7-iWeb-%E5%B3%B0%E4%BC%9A%E5%B0%8F%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016%E4%B8%8A%E6%B5%B7-iWeb-%E5%B3%B0%E4%BC%9A%E5%B0%8F%E8%AE%B0/</guid>
        <description>&lt;p&gt;早前在公众号看到会议的日程，果断报名参加了这次峰会。想对下午工具应用场的几个印象比较深刻多分享做一下小记。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1606071.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hax 的 《ES6+代码风格和质量标准》
Intel 的 《VR &amp;amp; Realsense in Crosswalk》
勾股 的 《Weex 跨平台渲染实现》&lt;/p&gt;

&lt;p&gt;###ES6+代码风格和质量标准###&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1606072.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/post/1606073.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hax 贺老还是一如既往喜欢用风趣来带入代码『哲学』问题。在人人都开始逐渐迈入 ES6 的时代，通过控制一个团队级别的代码风格规范，会更容易控制代码的质量。其中特意介绍了 ESLint，Eslint具有高度可配置、预置大量规则、可共享复用(git搜索 eslint-config)等等优势。大概的规则分为：可能是错误，最佳实践，变量声明等等，贺老的建议是能用的规则都用上。。。
事后有小伙伴专门用ESLint跑了一下代码，用贺老推荐的airbnb的代码规范，据说错误刷爆了，如下这种情况会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;
oneList.forEach(function(item) {
    // doSomething
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的代码会报 Missing function expression name 的警告。改成如下可以消除这个警告。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;
oneList.forEach(function each(item) {
    // doSomething
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前还不了解airbnb这样写的目的。如果有小伙伴知道请m我。。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;而ES6+的总体原则是尽量用Es6的语法，比如：ajax =&amp;gt; promise,Class工厂 =&amp;gt; 原生 Class 语法，arguments =&amp;gt; …args，&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;=&amp;gt; 函数默认参数，回调函数 =&amp;gt; 剪头函数等等。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;然后贺老还调侃了space党和tab党之间的偏见，算是一个轻松的话题引入，主要是分享了一个他写Atom插件: elastic-tabstops。同时推荐下Atom编辑器。&lt;/p&gt;

&lt;p&gt;就目前看来，代码规范这件事，还是要根据不同的情况：业务&amp;amp;框架、 ES5&amp;amp;ES6+、Brower&amp;amp;Node等不同场景来制定。&lt;/p&gt;

&lt;p&gt;附上演讲用的原版资料：http://johnhax.net/2015/es6-code-style/#0&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;###VR &amp;amp; Realsense in Crosswalk###&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1606074.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;都说今年是vr元年，之前就一直在想，前端离vr的距离是多远，这次分享就有了答案，前端能搞 VR？答案是 Yes！这次的 iWeb 峰会中，前端 VR 技术让我真正认识到 JS 真的没有什么不能做的。因特尔通过vr主推了他们的开源项目Crosswalk。Crosswalk 可以简单理解为增强版的 webkit，用于 Hybird 项目中，可替代原生的浏览器。对于前端vr场景而言，强悍的浏览器是支持vr的必不可少的一部分，
Crosswalk优势是多平台支持，对 WEBGL支持，对 VR，RealSense支持，知名应用比如有道云接入，谷歌的Mobile Chrome App团队接入，对兼容性的把握，对性能的优秀的处理等等。&lt;/p&gt;

&lt;p&gt;Crosswalk有三种接入模式：
嵌入模式，和native打包到一起，作为 HTML5页面的 webview 使用；
共享模式：不用打包到单个App中，系统只需要一个 crosswalk供所有应用去调用；
还有一种下载模式：好像是应用需要依赖 crosswalk，然后貌似自动会去 app store下载。&lt;/p&gt;

&lt;p&gt;最后我觉得想在业务中推广使用的硬伤还是体积问题，完整包大概20M左右，轻
量版也有10M，为了引入 crosswalk 安装包多10M，产品会噘嘴吧。。
当天早前在他们展位现场体验了webVR小游戏，效果狠酷炫，感受很真实，演讲中还讲到一项技术web for RealSense，用手隔空操作小车的移动。&lt;/p&gt;

&lt;p&gt;这次因特尔的vr分享使更多前端开发者有了一个新的方向和期待，未来出了平面化的web 前端开发，vr说不定会成为一个前端再次闪耀的新热点。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;###Weex 跨平台渲染实现###&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1606075.jpg&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Week 作为阿里近期主推的一款跨平台移动开发工具，这次会场中据说一半以上听众是冲着他来的。2015年双11，Weex 成功突围，算是成为阿里最好的跨平台工具，再从 QConf 宣布内测 和 iWeb 的分享 到 6 月份的正式开源，Weex 为更多人所认知，毕竟是大厂出品，又经过了双11的考验，可靠程度还是值得信任的。当天weex分享主要由勾股领衔，主要做了大概的产品介绍，Demo展示，如何调试，还有一些技术实现细节。Weex目前还是私有项目也只有Android部分，可以在&lt;a href=&quot;http://alibaba.github.io/weex/&quot;&gt;官网&lt;/a&gt;通过git帐号申请获取权限，计划在6月份完全开源。&lt;/p&gt;

&lt;p&gt;weex和react-native 是同类型的框架，但 weex 主打的是轻量，语法简单，上手容易。weex借鉴了 vue，而 vue 和 react 相比学习成本还是比较低的。&lt;/p&gt;

&lt;p&gt;Weex 和 React Native 的一大区别是模板的构建形式：&lt;/p&gt;

&lt;p&gt;React Naitve 的 UI 和业务逻辑一般是在一起的，这比较符合 Native 的开发习惯。 Weex 采用了前端常用的方式，模板和逻辑分离，而模板采用 vuejs、hogan、avalon、artTemplate 等等模板使用的  双大括号的形式，使前端工程师开发起来非常顺手。同时，Native 工程师学习使用 Weex ，成本将会提高。
最后，笔者感觉 Weex 是针对前端开发人员设计的一款工具框架，比较适合前端同学使用；而 React Native 是基于前端语言构建的一个 Native 框架，前端开发者会有一定的学习使用成本的同时（Native 的开发思想等），Native 开发者也会有一定的学习使用成本（ES6 语法等）。当然，环境搭建是共有的成本。&lt;/p&gt;

&lt;p&gt;weex框架也再次肯定了用js开发原生的这种模式，作为前端开发人员还是需要去多关注下。此外，vue社区今年应该会更活跃，关注度更高。&lt;/p&gt;

</description>
        <pubDate>Tue, 07 Jun 2016 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>js中继承的几种方式总结</title>
        <link>http://localhost:4000/blog/js%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/js%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</guid>
        <description>&lt;p&gt;总结一下js中继承的几种方式，主要从 apply,call,prototype 展开。&lt;/p&gt;

&lt;p&gt;###js中对象继承###&lt;/p&gt;

&lt;p&gt;js中有三种继承方式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.js原型（prototype）实现继承&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
    function Person(name,age){  
        this.name=name;  
        this.age=age;  
    }  
    Person.prototype.sayHello=function(){  
        console.log(&quot;使用原型得到Name：&quot;+this.name);  
    }  
    var per=new Person(&quot;cyan&quot;,21);  
    per.sayHello(); //输出：使用原型得到Name:cyan 

      
    function Student(){}  
    Student.prototype=new Person(&quot;cyan24&quot;,21);  
    var stu=new Student();  
    Student.prototype.grade=5;  
    Student.prototype.intr=function(){  
        console.log(this.grade);  
    }  
    stu.sayHello();//输出：使用原型得到Name:cyan24 
    stu.intr();//输出：5  


&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.构造函数实现继承&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
    function Parent(name){  
        this.name=name;  
        this.sayParent=function(){  
            console.log(&quot;Parent:&quot;+this.name);  
        }  
    }  

    function Child(name,age){  
        this.tempMethod=Parent;  
        this.tempMethod(name);  
        this.age=age;  
        this.sayChild=function(){  
            console.log(&quot;Child:&quot;+this.name+&quot;age:&quot;+this.age);  
        }  
    }  

    var parent=new Parent(&quot;cctest&quot;);  
    parent.sayParent(); //输出：“Parent:cctest”  
    var child=new Child(&quot;Jack&quot;,24); //输出：“Child:Jack age:24”  
    child.sayChild();  


&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.call , apply实现继承&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;

    function  Person(name,age,love){  
        this.name=name;  
        this.age=age;  
        this.love=love;  
        this.say=function say(){  
            alert(&quot;姓名：&quot;+name);  
        }  
    }  

    //call方式  
    function student(name,age){  
        Person.call(this,name,age);  
    }  

    //apply方式  
    function teacher(name,love){  
        Person.apply(this,[name,love]);  
        //Person.apply(this,arguments); //跟上句一样的效果，arguments  
    }  

    //call与aplly的异同：  
    //1,第一个参数this都一样,指当前对象  
    //2,第二个参数不一样：call的是一个个的参数列表；apply的是一个数组（arguments也可以）  

    var per=new Person(&quot;Andy&quot;,25,&quot;Mike&quot;); //输出：“Andy”  
    per.say();  
    var stu=new student(&quot;曲筱绡&quot;,18);//输出：“曲筱绡”  
    stu.say();  
    var tea=new teacher(&quot;关关&quot;,16);//输出：“关关”  
    tea.say();  


&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;###call和apply的用法（详细介绍）###&lt;/p&gt;

&lt;p&gt;js中call和apply都可以实现继承，唯一的一点参数不同，func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])。&lt;/p&gt;

&lt;p&gt;JS手册中对call的解释：&lt;/p&gt;

&lt;p&gt;call 方法调用一个对象的一个方法，以另一个对象替换当前对象。&lt;/p&gt;

&lt;p&gt;call([thisObj[,arg1[, arg2[,   [,.argN]]]]])&lt;/p&gt;

&lt;p&gt;参数 thisObj :可选项。将被用作当前对象的对象。&lt;/p&gt;

&lt;p&gt;arg1, arg2,  , argN  :可选项。将被传递方法参数序列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明 :&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。&lt;/p&gt;

&lt;p&gt;如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。&lt;/p&gt;

&lt;p&gt;说简单一点，这两函数的作用其实就是更改对象的内部指针，即改变对象的this指向的内容。这在面向对象的js编程过程中有时是很有用的。下面以apply为例，说说这两个函数在 js中的重要作用。如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
function Person(name,age){   //定义一个类   
    this.name=name;     //名字   
    this.age=age;       //年龄   
    this.sayhello=function(){alert(this.name)};  
}  
function Print(){            //显示类的属性   
    this.funcName=&quot;Print&quot;;  
    this.show=function(){  
        var msg=[];  
        for(var key in this){  
            if(typeof(this[key])!=&quot;function&quot;){  
                msg.push([key,&quot;:&quot;,this[key]].join(&quot;&quot;));  
            }  
        }  
        alert(msg.join(&quot; &quot;));  
    };  
}  
function Student(name,age,grade,school){    //学生类   
    Person.apply(this,arguments);//比call优越的地方   
    Print.apply(this,arguments);  
    this.grade=grade;                //年级   
    this.school=school;                 //学校   
}  

var p1=new Person(&quot;扎克伯格&quot;,80);  
p1.sayhello();  
var s1=new Student(&quot;白云飞&quot;,40,9,&quot;浙江大学&quot;);  
s1.show();  
s1.sayhello();  
alert(s1.funcName);
 
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;另外，&lt;strong&gt;在提升程序性能方面&lt;/strong&gt; Function.apply()有着明显的作用：
我们先从Math.max()函数说起，Math.max后面可以接任意个参数，最后返回所有参数中的最大值。
比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(Math.max(5,8));   //8   
alert(Math.max(5,7,9,3,1,6));   //9   

//但是在很多情况下，我们需要找出数组中最大的元素。   

var arr=[5,7,9,1];  
//alert(Math.max(arr));    // 这样却是不行的。NaN   

//要这样写   
function getMax(arr){  
    var arrLen=arr.length;  
    for(var i=0,ret=arr[0];i&amp;lt;arrLen;i++){  
        ret=Math.max(ret,arr[i]);  
    }  
    return ret;  
}  

alert(getMax(arr)); //9   

//换用apply，可以这样写   
function getMax2(arr){  
    return Math.max.apply(null,arr);  
}  

alert(getMax2(arr)); //9   

//两段代码达到了同样的目的，但是getMax2却优雅，高效，简洁得多。   

//再比如数组的push方法。   
var arr1=[1,3,4];  
var arr2=[3,4,5];  
//如果我们要把 arr2展开，然后一个一个追加到arr1中去，最后让arr1=[1,3,4,3,4,5]   
//arr1.push(arr2)显然是不行的。 因为这样做会得到[1,3,4,[3,4,5]]   

//我们只能用一个循环去一个一个的push(当然也可以用arr1.concat(arr2)，但是concat方法并不改变arr1本身)   

var arrLen=arr2.length;  
for(var i=0;i&amp;lt;arrLen;i++){  
    arr1.push(arr2[i]);  
}  

//自从有了Apply,事情就变得如此简单   

Array.prototype.push.apply(arr1,arr2); //现在arr1就是想要的结果
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Wed, 04 May 2016 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>web动画中的requestAnimationFrame</title>
        <link>http://localhost:4000/blog/web%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84requestAnimationFrame/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/web%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84requestAnimationFrame/</guid>
        <description>&lt;p&gt;在HTML5/CSS3普遍应用的今天，在web里做动画选择其实已经很多了:&lt;/p&gt;

&lt;p&gt;CSS3的animattion+keyframes;&lt;/p&gt;

&lt;p&gt;css3的transition;&lt;/p&gt;

&lt;p&gt;或者是canvas上作图来实现动画，也可以借助jQuery动画相关的API方便地实现;&lt;/p&gt;

&lt;p&gt;当然最原始的你还可以使用window.setTimout()或者window.setInterval()通过不断更新元素的状态位置等来实现动画，前提是画面的更新频率要达到每秒60次也就是16.7ms ,才能让肉眼看到流畅的动画效果。&lt;/p&gt;

&lt;p&gt;以上方法几乎可以完成平时的百分之九十的需求，那requestAnimationFrame还有什么存在的价值呢～～？
先来一步步认识一下他吧！&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;###requestAnimationFrame是什么###&lt;/p&gt;

&lt;p&gt;我们先看看&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;MND&lt;/a&gt;上怎么说明的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes as an argument a callback to be invoked before the repaint.&lt;/em&gt;
&lt;em&gt;window.requestAnimationFrame() 将告知浏览器你马上要开始动画效果了，后者需要在下次动画前调用相应方法来更新画面。这个方法就是传递给window.requestAnimationFrame()的回调函数。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实就是和我们熟悉的setTimeout/setInterval差不多，通过递归调用同一方法来不断更新画面以达到动起来的效果，但它优于setTimeout/setInterval的地方在于它是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;###我们怎么用###&lt;/p&gt;

&lt;p&gt;可以直接调用，也可以通过window来调用，接收一个函数作为回调，返回一个ID值，通过把这个ID值传给window.cancelAnimationFrame()可以取消该次动画。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;
requestAnimationFrame(callback)//callback为回调函数

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;###一个煎蛋的栗子###&lt;/p&gt;

&lt;p&gt;模拟一个进度条动画，初始div宽度为1px,在step函数中将进度加1然后再更新到div宽度上，在进度达到100之前，一直重复这一过程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;test&quot; style=&quot;width:1px;height:17px;background:#0f0;&quot;&amp;gt;0%&amp;lt;/div&amp;gt;
&amp;lt;input type=&quot;button&quot; value=&quot;Run&quot; id=&quot;run&quot;/&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
var start = null;
var ele = document.getElementById(&quot;test&quot;);
var progress = 0;

function step(timestamp) {
    progress += 1;
    ele.style.width = progress + &quot;%&quot;;
    ele.innerHTML=progress + &quot;%&quot;;
    if (progress &amp;lt; 100) {
        requestAnimationFrame(step);
    }
}
requestAnimationFrame(step);
document.getElementById(&quot;run&quot;).addEventListener(&quot;click&quot;, function() {
    ele.style.width = &quot;1px&quot;;
    progress = 0;
    requestAnimationFrame(step);
}, false);

&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;###兼容情况###
来看看它的&lt;a href=&quot;http://caniuse.com/#search=requestAnimationFrame&quot;&gt;兼容&lt;/a&gt;情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1604051.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;###备胎这件事###&lt;/p&gt;

&lt;p&gt;是的你没有看错，我们要插播一下Polyfill ，也就是相当于兼容方案中的备胎。&lt;/p&gt;

&lt;p&gt;Polyfill也有称作垫片，按发明这个词的人的原话来说，它就是一段这样的代码，让浏览器原生地支持我们期望使用的一些API。&lt;/p&gt;

&lt;p&gt;就比如这里的requestAnimationFrame，在看到了上面的浏览器支持情况后，你就知道了比上面列出的浏览器版本老的就不支持该方法，但为了让代码能够有更好的浏览器兼容性在老机器上也能运行不报错，我们可以写一些代码让浏览器在不支持requestAnimationFrame的情况下使用window.setTimeout()，这是一种回退（fallback）到过去的方法。&lt;/p&gt;

&lt;p&gt;这样一来，就可以通俗一点的理解polyfill了，它就是备胎。&lt;/p&gt;

&lt;p&gt;下面是由Paul Irish及其他贡献者放在GitHub Gist上的代码片段，用于在浏览器不支持requestAnimationFrame情况下的备胎方案，回退到使用setTmeout的情况。当然，如果你确定代码是工作在较新大浏览器中，下面的代码是不必的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
// MIT license
(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x &amp;lt; vendors.length &amp;amp;&amp;amp; !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }
    if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16.7 - (currTime - lastTime));
        var id = window.setTimeout(function() {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}());

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码作用有二，一是把各浏览器前缀进行统一，二是在浏览器没有requestAnimationFrame方法时将其指向setTimeout方法。&lt;/p&gt;

&lt;p&gt;提到备胎代码呢，这里多说一句，在CSS代码中，我们也经常使用这种回退的技巧，即对同一条CSS规则，编写多条以不同浏览器前缀开头代码，或者编写一条备用样式。&lt;/p&gt;

&lt;p&gt;下面是一个CSS中的备胎代码的栗子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;div {
    background: rgb(0, 0, 0); /* fallback */
    background: rgba(0, 0, 0, 0.5);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码中设置div背景为黑色带50%的透明度，但IE9-的浏览器是不支持rbga格式的颜色的，所以浏览器会回退到上一条CSS规则应用rgb颜色。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;一些补充&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据&lt;a href=&quot;https://segmentfault.com/a/1190000000386368&quot;&gt;这篇翻译文章&lt;/a&gt;一些测试说法，FireFox/Chrome浏览器对setInterval, setTimeout做了优化，页面处于闲置状态的时候，如果定时间隔小于1秒钟(1000ms)，则停止了定时器。与requestAnimationFrame有类似行为。但如果时间间隔大于或等于1000ms，定时器依然执行，即使页面最小化或非激活状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1604052.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;article about rAF from css tricks: http://css-tricks.com/using-requestanimationframe/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;article about rAF from Paul Irish:http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;what is polyfill http://remysharp.com/2010/10/08/what-is-a-polyfill/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;翻译：setInterval与requestAnimationFrame的时间间隔测试 http://blog.segmentfault.com/humphry/1190000000386368&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 05 Apr 2016 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>用chrome实时调试less编译的文件</title>
        <link>http://localhost:4000/blog/%E7%94%A8chrome%E5%AE%9E%E6%97%B6%E8%B0%83%E8%AF%95less%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%87%E4%BB%B6%E5%89%AF%E6%9C%AC-2/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/%E7%94%A8chrome%E5%AE%9E%E6%97%B6%E8%B0%83%E8%AF%95less%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%87%E4%BB%B6%E5%89%AF%E6%9C%AC-2/</guid>
        <description>&lt;p&gt;首先看下chrome调试时，如何实时保存到本地文件。使用chrom调试工具中的 source 进入项目目录结构，右键选择本地文件目录add floder to workspace ,添加本地文件夹，之后选择本地文件右键map to network resource。
这样就能映射本地文件直接指向服务文件，也就是在chrome中直接调试样式后，ctrl+S 后直接同步保存到了本地文件。
接下来我们要使用chorm实时调试less文件，首先要安装一个监听文件 wr,类似grunt的watch,选择wr是因为他的速度相对其他监听软件快！先执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
npm install -g wr 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全局安装wr,之后开始我们可以实时监听到lessc 编译某一个less的命令：&lt;/p&gt;

&lt;p&gt;比如：在less文件目录执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
wr ‘less duang.less duang.css’ duang.less

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以监听到当我们改变duang.less时，然后保存，可以看到duang.css同时做了自动编译后的改变。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1602231.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那怎么实时去改变chrom里的css从而改变到less呢～？
现在我们要做的就是怎么把css和less做一个映射，我们用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
lessc —source-map duang.less duang.css
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去做一个资源映射。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1602232.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同级目录马上生成一个map文件：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1602233.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在css文件底部，可以看到一个映射关系的说明：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1602234.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;开启浏览器映射功能：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1602235.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/post/1602236.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后执行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
wr 'lessc --source-map duang.less duang.css' duang.less

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1602237.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时修改chrome中的less文件，保存刷新浏览器，同步可以修改本地的less 和css了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1602238.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;标题修改为红色：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1602239.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本地css和less都已自动修改：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/16022310.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/16022311.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上说的这种方式在chrome调试工具的elements - Styles 下暂时没有办法做实时调试，着也是比较遗憾的一点。&lt;/p&gt;

</description>
        <pubDate>Wed, 23 Mar 2016 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>关于css3 动画的一点笔记</title>
        <link>http://localhost:4000/blog/%E5%85%B3%E4%BA%8Ecss3-%E5%8A%A8%E7%94%BB%E7%9A%84%E4%B8%80%E7%82%B9%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/%E5%85%B3%E4%BA%8Ecss3-%E5%8A%A8%E7%94%BB%E7%9A%84%E4%B8%80%E7%82%B9%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;p&gt;代码中当要使用transform 和 opicity 比如同时0.3秒过渡时，下面这种写法不推荐，因为all会引起性能问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;
div {
     transform :translate (0 ,-20px);
     transition: all 0.3s ease;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐使用下面这种写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;
div {
     transform :translate (0 ,-20px);
     transition: opacity 0.3s ease,transform 0.3s ease;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，在兼容各种webkit 的写法时，可以使用autoprefixer 插件，在less编译成css时再编译一次，可以高效得把各种前缀都自动加了。&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Mar 2016 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>D2前端论坛分享——阿里篇</title>
        <link>http://localhost:4000/blog/D2%E5%89%8D%E7%AB%AF%E8%AE%BA%E5%9D%9B%E5%88%86%E4%BA%AB%E4%B9%8B%E9%98%BF%E9%87%8C%E7%AF%87/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/D2%E5%89%8D%E7%AB%AF%E8%AE%BA%E5%9D%9B%E5%88%86%E4%BA%AB%E4%B9%8B%E9%98%BF%E9%87%8C%E7%AF%87/</guid>
        <description>&lt;p&gt;前段时间回顾了一下d2论坛上阿里的分享环节，由sima分享的关于天猫的node改造历程。
首先看对比改造和未改造，性能方面的提升。在改造后使用了nodejs的页面和未改造的页面使用的时php，在2014双十一RT 和 QPS对比：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1511031.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上图看出，node 的RT 和 QPS 性能数据较php有大幅度优势。&lt;/p&gt;

&lt;p&gt;从页面渲染的本质来看，可以从三个维度来看：&lt;/p&gt;

&lt;p&gt;1.前端开发编写维护的模版；&lt;/p&gt;

&lt;p&gt;2.运营维护或者后端系统产出的数据；&lt;/p&gt;

&lt;p&gt;3.通过一个渲染容器进行合并产出页面。&lt;/p&gt;

&lt;p&gt;示例如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1601101.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过扩展上下文，可以使前端写出简单的逻辑判断。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1601102.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于模版中的静态资源管理，他们是这么处理的：&lt;/p&gt;

&lt;p&gt;1.前后端使用统一的资源加载器；&lt;/p&gt;

&lt;p&gt;2.基于统一的seed控制依赖以及版本；&lt;/p&gt;

&lt;p&gt;3.输出combo url到页面；&lt;/p&gt;

&lt;p&gt;4.依赖自动去重，css/js头尾加载。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1601103.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;渲染出来后的页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1601104.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外，也做了大量点模块化工作。通过模块化，前端写的90个模块被运营组合扩展成700个页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1601105.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1601106.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;搭建出来大概是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1601107.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;阿里从模块化到规模化大概要经历这三个过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;跨业务共享模块；&lt;/li&gt;
  &lt;li&gt;面向运营的可视化页面搭建平台；&lt;/li&gt;
  &lt;li&gt;Native 页面搭建。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###如何用NODE架构起服务###&lt;/p&gt;

&lt;p&gt;他们的服务并没有使用express,而是使用了koa,在渲染页面方面使用了扩展的xtemplate模版，通过阿里云oss提供模板和数据的存储支持，而cdn使用了阿里的的cdn缓存支持。&lt;/p&gt;

&lt;p&gt;作为koa的github维护者之一，本次分享中，sima对koa的讲解占了一定的篇幅.&lt;/p&gt;

&lt;p&gt;koa不仅仅作为generator，相比于express的作为中间件顺序执行的特点，他是包裹在后面所有中间件的装饰器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1601109.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1601108.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试覆盖率和集成测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;让测试覆盖率告诉你bug在哪儿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/16011010.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般很难覆盖的地方都是比较容易出bug的地方.&lt;/p&gt;

&lt;p&gt;持续集成察觉每次代码变更引入的风险。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/16011011.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于Cluster&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Master 只做进程管理;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;worker 异常退出后自动重启（cfork）;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http 服务优雅退出（graceful)。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对关键指标做了监控，而异常对信息，做了警告处理。
所以一定要有日志记录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于日志&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;做了以下处理：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;所有的请求都有accesslog追踪；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所有异常统一记录，并分类输出；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;依赖系统调用tracelog,记录请求和响应情况。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于这些监控，可以获得到警告信息（如果有的话）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于警告&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在以下情况作了警告的处理：&lt;/p&gt;

&lt;p&gt;系统/服务状态异常的情况下如RT增高/Load增高情、依赖异常如调用失败/调用超时、服务异常如出现日常日志的情况。对于异常日志信息通过短信或者邮件反应。&lt;/p&gt;

&lt;p&gt;这样就可以通过警告快速感知错误信息，通过日志和监控快速定位问题，目的是快速恢复服务。但是sima也提醒，最好是通过完善的单元测试去避免这些线上故障。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;双十一==DDOS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每次双十一，对于阿里来说无疑都是一次类似ddos攻击，阿里的应对策略是合理利用CDN,在未改造之前需要使用几百台实体机做渲染，而改造完后用几十台虚拟机久完成了响应的活儿。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/16011012.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了保证在CDN情况下能保证一些业务逻辑能正常运行，比如基于CDN的URL统一，比如输入www.tmall.com, 在手机上看到的和pc上看到的页面一定是不一样的，而对cdn来说却是同一份缓存内容，所以需要处理成不同终端请求同一个url时，cdn能识别设备型号，渲染服务返回不同的页面。处理方式是在cdn安装了插件来做识别.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;容灾和预案&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;给出的建议是消灭单点，做异地双机房部属，oss双节点主备容灾，数据模板磁盘文件容灾。也做了预案自动化，cdn会在机房间不停得做回源健康检查，如果有异常能在10s内自动切换到健康的机房。oss健康检查，异常自动切换主备。系统load过高，自动切换静态备份。渲染异常自动切换静态备份。&lt;/p&gt;

</description>
        <pubDate>Sun, 10 Jan 2016 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>移动端开发用户体验提升的几个方案</title>
        <link>http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%A1%88/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%A1%88/</guid>
        <description>&lt;p&gt;H5在移动端的运用中由于种种原因，用户体验一直无法媲美原生开发的使用体验，最近对AC前端大会上腾讯前端组的分享做一个总结。&lt;/p&gt;

&lt;p&gt;下面有几点方式可以尽可能的使用户体验接近原生的体验。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用点击态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;点击态能够给用户明确的点击反馈，提升用户体验。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方案1:使用active伪类，其缺点是滚动的时候也会触发样式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们一般使用以下方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方案2:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;
$el.on('tap',function(e){
   var $target = $(e.target);
   $target.addClass('active');
   
   setTimeout(function(){
      $target.removeClass('active');
   },150)

})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关于页面滚动&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先看一个页面滚动的定义：
页面滚动可以分为局部滚动和全局滚动。全局滚动是指滚动条在body节点或者更顶层。局部滚动是指滚动条在body下的某个dom节点上。&lt;/p&gt;

&lt;p&gt;在ios上 默认支持全局滚动，对于局部滚动，默认没有滚动条，且滑动起来干涩。&lt;/p&gt;

&lt;p&gt;在ios局部滚动用以下代码实现弹性滚动效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1511141.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;建议：将属性挂在body上，可以避免很多奇怪的bug.&lt;/p&gt;

&lt;p&gt;在安卓方面，因为定制版本比较多，表现各异。默认没有弹性滚动效果。
以下效果默认浏览器不支持，安卓版的chrome下支持。
&lt;img src=&quot;/img/post/1511142.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在ios下如使用局部滚动，解决方案是：
使用scrollFix:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;if(startTopScroll &amp;lt;=0)
   elem.scrollTop = 1;

if(startTopScroll + elem.offsetHeight &amp;gt;= elem.scrollHeight)
   elem.scrollTop = elem.scrollHeight - elem.offsetHeight - 1 ;
   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1511147.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;局部滚动长列表的优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;方案1:使用div局部滚动&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/15111418.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;方案2:div原生滚动连动内容层&lt;/p&gt;

&lt;p&gt;折中的方案：分离滚动层与内容层，滚动的加速减速仍由滚动层div局部滚动控制，通过监听div的scroll事件，联动内容层：
&lt;img src=&quot;/img/post/15111419.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种方案在小米手机上出现了严重的问题，滚动时，内容直接从起始位置瞬间跳到了终点位置。虽然div 的scroll事件可以触发，但是scroll过程中产生的样式变更，却要等到滚动结束后才能渲染。
资料中对旧版ios的描述，与小米手机相似：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/15111420.png&quot; alt=&quot;&quot; /&gt; 
&lt;img src=&quot;/img/post/15111421.png&quot; alt=&quot;&quot; /&gt; 
___&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于键盘定制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在英文输入法下，输入首字母如果要取消自动首字母大写，可以使用autocapitalize = ‘off’ 这个属性：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1511144.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于键盘定制的行为和样式，在ios下基本支持，在安卓下不同系统不同定制版本支持情况不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;移动web首屏时间概念&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;移动web首屏优化实践：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1511148.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过网络阶段后在服务端渲染时，以webp为例，过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/15111410.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从可优化幅度到角度看，网络层面的优化比渲染方面的优化带来的红利更多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1511149.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/15111411.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们要关注一个概念，也就是RTT,RTT是指一个回路时间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/15111412.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/15111413.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络耗时的测定&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;html5提供了网络测速方法；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Navigation Timing:获得主页相关性能数据；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Resource Timing:获得主页相关资源的性能数据（iframe,image,script,audio,vedio…）;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们的最终目标是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;减小请求数；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;减小传输提及；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尽可能得利用缓存；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缩短关键路径；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;合理安排请求顺序。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体方案：&lt;/p&gt;

&lt;p&gt;1.DNS 预解析&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/15111414.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.域名收敛&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/15111415.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3.链路复用&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/15111416.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 14 Nov 2015 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>移动端a标签href点击跳转到下一个页面同位置上的&lt; a href&gt;穿透点击事件解决</title>
        <link>http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AFa%E6%A0%87%E7%AD%BEhref%E7%82%B9%E5%87%BB%E8%B7%B3%E8%BD%AC%E5%88%B0%E4%B8%8B%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%90%8C%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84-a-href-%E7%A9%BF%E9%80%8F%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E8%A7%A3%E5%86%B3/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AFa%E6%A0%87%E7%AD%BEhref%E7%82%B9%E5%87%BB%E8%B7%B3%E8%BD%AC%E5%88%B0%E4%B8%8B%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%90%8C%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84-a-href-%E7%A9%BF%E9%80%8F%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E8%A7%A3%E5%86%B3/</guid>
        <description>&lt;p&gt;项目中遇到的一个问题。移动开发的h5页面上(部分安卓机型)，点击前一个页面的a标签，进入下一个页面后，此时下一个页面的相同位置上也有一个a标签，此时会将后一个页面中的a标签点击触发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;解决方案：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将原来的&amp;lt; a&amp;gt;标签改为 div ，用移动端的 ontouchstart 事件代替，此时前一个页面点击事件不会穿透到下一个页面同位置的点击区域。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
$(function () {
         var div = document.getElementById(&quot;operate_tbkp&quot;);
         //touchstart类似mousedown
         //div.ontouchstart = function(e){
         div.ontouchstart = function(e){
         //事件的touches属性是一个数组，其中一个元素代表同一时刻的一个触控点，从而可以通过touches获取多点触控的每个触控点
         //由于我们只有一点触控，所以直接指向[0]
         //var touch = e.touches[0];
         //获取当前触控点的坐标，等同于MouseEvent事件的clientX/clientY
         //var x = touch.clientX;
         //var y = touch.clientY;
         window.location.href='../applicationformAppcs/formBilling';
         };
 })

&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 22 Oct 2015 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>H5开发中四种页面横向滑动模式</title>
        <link>http://localhost:4000/blog/H5%E5%BC%80%E5%8F%91%E4%B8%AD%E5%9B%9B%E7%A7%8D%E9%A1%B5%E9%9D%A2%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/H5%E5%BC%80%E5%8F%91%E4%B8%AD%E5%9B%9B%E7%A7%8D%E9%A1%B5%E9%9D%A2%E6%A8%AA%E5%90%91%E6%BB%91%E5%8A%A8%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;p&gt;近年来移动网络速率的提升以及设备硬件水平的不断提高，webapp朝着更趋向于native化的水平发展，其表现效果和性能也会越来越好，现在来看未来很有可能替代native或者平起平坐，那么我们研究更好的交互体验是非常有必要的。&lt;/p&gt;

&lt;p&gt;目前我们所常见的webapp越来越多的是以SPA(single page application)的模式进行开发，同时嵌套在android或者ios本地壳里面，也就是hybrid应用，这种开发方式所带来的优势就不多讨论，本文研究的重点是在SPA模式中，页面间横向滑动切换场景时模式是怎样设计的，将展示并阐述四种横向滑动模式的架构布局及CSS设计方案，供大家参考。&lt;/p&gt;

&lt;p&gt;一、容器整体滑动（DEMO只演示A-B-C-B，下同）
模拟动画效果见下图(上)，滑动分解见下图(下)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1509201.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1509202.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nirvana.sinaapp.com/demo_slider/slider_1.html&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;布局方式：父容器相对定位并撑满整个device的viewport，子页面绝对定位并依次并排排列在viewport中（从左到右）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.view-container { // 父容器布局方式
  position: relative;
  width: 100%;
  height: 100%;
  padding-top: 44px;
  box-sizing: border-box;
  -webkit-transform: translate3d(0,0,0); //激活GPU 3D加速
  -webkit-backface-visibility: hidden;
}
.page-container { // 子页面布局方式
  position: absolute;
  z-index: 1;
  top: 0;
  left: 0; // 初始化为0，动态计算第N个page，并赋值(N-1)*100%
  width: 100%;
  height: 100%;
  overflow: hidden;
  background-color: #F8F8F8;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;滑动方式：父容器利用CSS3的动画transform3D进行X轴的滑动(JS控制直接喷到DOM节点中)
___&lt;/p&gt;

&lt;p&gt;二、单个页面滑动
模拟动画效果，见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1509202.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1509203.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nirvana.sinaapp.com/demo_slider/slider_2.html&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;布局方式：父容器高度100%，子容器正常文档流布局（X轴隐藏，Y轴默认原生滚动）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.view-container {        
  height: 100%;
}
.page-container {
  position: relative;
  width: 100%;
  min-height: 100%;
  overflow-x: hidden;
  background-color: #F8F8F8;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;滑动方式：利用class添加动画样式（keyframes animation），左右进出各一种&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;  @-webkit-keyframes sliderightout{from{-webkit-transform:translateX(0px);opacity:1}to{-webkit-transform:translateX(50%);opacity:0}}
  @-webkit-keyframes slideleftin{from{-webkit-transform:translateX(-50%);opacity:0}to{-webkit-transform:translateX(0px);opacity:1}}
  @-webkit-keyframes slideleftout{from{-webkit-transform:translateX(0px);opacity:1}to{-webkit-transform:translateX(-50%);opacity:0}}
  @-webkit-keyframes sliderightin{from{-webkit-transform:translateX(50%);opacity:0}to{-webkit-transform:translateX(0px);opacity:1}}

  .slideleftout{-webkit-animation:slideleftout 350ms ease-in-out;}
  .slideleftin{-webkit-animation:slideleftin 350ms ease-in-out;}
  .sliderightout{-webkit-animation:sliderightout 350ms ease-in-out;}
  .sliderightin{-webkit-animation:sliderightin 350ms ease-in-out;}
  .animatestart{position:absolute;top:0;left:0;z-index:3;width:100%;height:100%;overflow-x:hidden}
  .animatestart.page-container{overflow-x:hidden;-webkit-transform:translate3d(0,0,0);-webkit-backface-visibility:hidden;background-color:#f5f5f5}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;三、双页联动滑动
模拟动画效果，见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1509203.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1509204.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nirvana.sinaapp.com/demo_slider/slider_3.html&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;布局方式：类似于第一种，父容器和子容器都绝对定位于viewport中，不同点是父类的上级布局更加细分，且大胆使用了webkit-box弹性盒子；子容器没有并排显示，而是重叠隐藏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.view-container {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
}
.page-container {
  position: absolute;
  z-index: 1;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background-color: #F8F8F8;
  -webkit-transform:translate3d(0,0,0);
  -webkit-backface-visibility:hidden;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;滑动方式：滑动开始时先将隐藏的下一个子页面拉到viewport右侧与当前子页面平行，然后紧接着两个子页面同步滑动，最后回归样式，中间的时间差事件均有JS控制（详见demo逻辑）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;四、三舞台双页视差滑动
模拟动画效果见下图（上），分解逻辑图见下图（下）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1509204.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/1509205.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nirvana.sinaapp.com/demo_slider/slider_4.html&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;布局方式：这里我设定了三舞台(stage)的概念，其实就是当前viewport的左右侧各虚拟一个同样大小的viewport，当然，正常情况下我们只能看到当前舞台的子页面，leftstage是-100%的位置，rightstage是100%的位置，我们分别用三个class来定义：pageOld、pageInit、pageNew来代替&lt;/p&gt;

&lt;p&gt;.pageInt {
  -webkit-transform: translateX(0);
          transform: translateX(0);
  }
.pageOld {
  -webkit-transform: translateX(-100%);
          transform: translateX(-100%);
  }
.pageNew {
  -webkit-transform: translateX(100%);
          transform: translateX(100%);
  }
}
滑动方式：
1，定义正向（向左滑）和反向（向右滑）两个概念,；
2，定义快速和慢速两个概念；
则就是四种动态两种组合：正向快速+正向慢速、反向快速+反向慢速；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.slideSlow {
  -webkit-transition: -webkit-transform 400ms cubic-bezier(0.42, 0, 0.58, 1.0) 0.1s;
      -ms-transition: transform 400ms cubic-bezier(0.42, 0, 0.58, 1.0) 0.1s;
}
.slideFast {
  -webkit-transition: -webkit-transform 300ms cubic-bezier(0.42, 0, 0.58, 1.0);
      -ms-transition: transform 300ms cubic-bezier(0.42, 0, 0.58, 1.0);
}
.slideSlowBack {
  -webkit-transition: -webkit-transform 400ms cubic-bezier(0.42, 0, 0.58, 1.0);
      -ms-transition: transform 400ms cubic-bezier(0.42, 0, 0.58, 1.0);
}
.slideFastBack {
  -webkit-transition: -webkit-transform 300ms cubic-bezier(0.42, 0, 0.58, 1.0) 0.1s;
      -ms-transition: transform 300ms cubic-bezier(0.42, 0, 0.58, 1.0) 0.1s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中在三舞台视差滑动中的滑动曲线是经过数次的真机实验后找到的参数（cubic-bezier(0.42, 0, 0.58, 1.0)），这条曲线的滑动形态最接近IOS APP页面的滑动，希望对大家有用，鉴于时间精力有限，这四种模式只能从架构布局和样式设计层面探讨，关于WEBAPP性能架构及一些深层次的问题，欢迎与我交流（微博@忆龙Lau），相互学习！&lt;/p&gt;

&lt;p&gt;相关资料：
四种架构分别来源于：携程商旅无线2.0、携程无线、SenchaTouch UI、携程商旅无线3.0(Nirvana)；&lt;/p&gt;

&lt;p&gt;JS框架工具有：zeptojs（移动端基础框架库），iscroll（纵向平滑滑动工具）,fastclick（快速点击事件）,backbone（MVC架构）；&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Sep 2015 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>移动设备tab圆角图片，出现阴影解的bug</title>
        <link>http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87tab%E5%9C%86%E8%A7%92%E5%9B%BE%E7%89%87-%E5%87%BA%E7%8E%B0%E9%98%B4%E5%BD%B1%E8%A7%A3%E7%9A%84bug/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87tab%E5%9C%86%E8%A7%92%E5%9B%BE%E7%89%87-%E5%87%BA%E7%8E%B0%E9%98%B4%E5%BD%B1%E8%A7%A3%E7%9A%84bug/</guid>
        <description>&lt;p&gt;做好的页面在手机端测试时，发现部分浏览器，tap后会出现一个半透明的灰色背景，发现是tap后的背景高亮，要重设这个表现，则需要设置-webkit-tap-highlight-color为所需色彩，直接透明吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a,img,button,input,textarea{-webkit-tap-highlight-color:rgba(255,255,255,0);}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，如何去掉textarea,input的默认样式（IOS上的圆角及内阴影等，Android未测试）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;input,textarea{-webkit-appearance:none;}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 18 Sep 2015 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>.jpg、.png转换成.webp</title>
        <link>http://localhost:4000/blog/.jpg-.png%E8%BD%AC%E6%8D%A2%E6%88%90.webp/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/.jpg-.png%E8%BD%AC%E6%8D%A2%E6%88%90.webp/</guid>
        <description>&lt;p&gt;一、什么是Webp
       WebP是Google新推出的影像技术，它可让网页图档有效进行压缩，同时在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%，进而让整体网页下载速度加快。为了改善JPEG的图片压缩技术，他们使用了一种基于VP8编码(已在2010五月开源)的图片压缩器，利用预测编码技术，同时还采用了一种基于RIFF的非常轻量级的容器。这种容器只会给每张图片增加20字节，但能让图片作者保存他们想要存储的元数据。
与JPEG相同，WebP是一种有损压缩利用预测编码技术。&lt;/p&gt;

&lt;p&gt;二、Webp文件制作准备&lt;/p&gt;

&lt;p&gt;Google开发并放出了不同操作系统的WebP文件解码器(libvpx)和命令行工具(webpconv)。
下载地址：
&lt;a href=&quot;http://code.google.com/intl/zh-CN/speed/webp/download.html&quot;&gt;http://code.google.com/intl/zh-CN/speed/webp/download.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我下载了用于Windows的WebpCodecSetup.exe 和libwebp-0.1.3-windows-x86.zip&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先安装WebpCodecSetup.exe，&lt;/li&gt;
  &lt;li&gt;解压libwebp-0.1.3-windows-x86.zip（无需安装）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三、Jpg或png转换到Webp方法&lt;/p&gt;

&lt;p&gt;进入libwebp-0.1.3-windows-x86.zip的解压目录，可以看到cwebp.exe和dwebp.exe，其中cwebp.exe是将jpg或png文件转换成webp文件，dwebp.exe是将webp文件转换成png、pp或pgm。这两个程序只能在dos命令行环境下运行&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;点击“开始”-&amp;gt;“运行”-&amp;gt;输入 cmd 后回车进入dos环境&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输入路径进入解压文件夹，以下是我安装的路径&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;C:\Documents andSettings\Administrator&amp;gt;e:
E:&amp;gt;cd libwebp-0.1.3-windows-x86
E:\libwebp-0.1.3-windows-x86&amp;gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;输入命令，将jpg或png转换成webp&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;命令行结构：cwebp [-preset &amp;lt;…&amp;gt;] [options] in_file [-o out_file]&lt;/p&gt;

&lt;p&gt;E:\libwebp-0.1.3-windows-x86&amp;gt; cwebp -qquality e:\photo\png1.png -o e:\webp1.webp （回车）
（e:\photo\png1.png是原文件路径，e:\webp1.webp是目标文件路径）&lt;/p&gt;

&lt;p&gt;Saving file ‘ webp1.webp’&lt;/p&gt;

&lt;p&gt;27672 bytes Y-U-V-All-PSNR 30.30 32.22 32.78   30.91 dB&lt;/p&gt;

&lt;p&gt;block count:  intra4: 1372&lt;/p&gt;

&lt;p&gt;intra16: 10378  (-&amp;gt; 88.32%)&lt;/p&gt;

&lt;p&gt;skipped block: 6204 (52.80%)&lt;/p&gt;

&lt;p&gt;bytes used: header: 131  (0.5%)&lt;/p&gt;

&lt;p&gt;mode-partition: 13138  (47.5%)&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Residuals bytes&lt;/td&gt;
      &lt;td&gt;segment 1&lt;/td&gt;
      &lt;td&gt;segment 2&lt;/td&gt;
      &lt;td&gt;segment 3&lt;/td&gt;
      &lt;td&gt;segment4&lt;/td&gt;
      &lt;td&gt;total&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;intra4-coeffs:&lt;/td&gt;
      &lt;td&gt;3918&lt;/td&gt;
      &lt;td&gt;911&lt;/td&gt;
      &lt;td&gt;268&lt;/td&gt;
      &lt;td&gt;65&lt;/td&gt;
      &lt;td&gt;5162  (18.7%)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;intra16-coeffs:&lt;/td&gt;
      &lt;td&gt;3086&lt;/td&gt;
      &lt;td&gt;1964&lt;/td&gt;
      &lt;td&gt;881&lt;/td&gt;
      &lt;td&gt;240&lt;/td&gt;
      &lt;td&gt;6171 (22.3%)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;chroma coeffs:&lt;/td&gt;
      &lt;td&gt;1627&lt;/td&gt;
      &lt;td&gt;902&lt;/td&gt;
      &lt;td&gt;408&lt;/td&gt;
      &lt;td&gt;105&lt;/td&gt;
      &lt;td&gt;3042 (11.0%)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;macroblocks:&lt;/td&gt;
      &lt;td&gt;27%&lt;/td&gt;
      &lt;td&gt;33%&lt;/td&gt;
      &lt;td&gt;26%&lt;/td&gt;
      &lt;td&gt;12%&lt;/td&gt;
      &lt;td&gt;11750&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;quantizer:&lt;/td&gt;
      &lt;td&gt;127&lt;/td&gt;
      &lt;td&gt;127&lt;/td&gt;
      &lt;td&gt;127&lt;/td&gt;
      &lt;td&gt;127&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;filter level:&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;——————————————————————————————————————&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;segments total:&lt;/td&gt;
      &lt;td&gt;8631&lt;/td&gt;
      &lt;td&gt;3777&lt;/td&gt;
      &lt;td&gt;1557&lt;/td&gt;
      &lt;td&gt;410&lt;/td&gt;
      &lt;td&gt;14375  (51.9%)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;转换成功，在E:\libwebp-0.1.3-windows-x86目录中会生成一个webp1.webp文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cwebp通过不同命令的选项，可以对图片的大小、尺寸打印信息等进行设置。
E:\libwebp-0.1.3-windows-x86&amp;gt;cwebp.exe –H（回车）
options:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;-h / -help ………… short help&lt;/p&gt;

&lt;p&gt;-H / -longhelp  …….. long help&lt;/p&gt;

&lt;p&gt;-q …………. qualityfactor (0:small..100:big)&lt;/p&gt;

&lt;p&gt;-preset ……. Presetsetting, one of:&lt;/p&gt;

&lt;p&gt;default, photo, picture,&lt;/p&gt;

&lt;p&gt;drawing, icon, text&lt;/p&gt;

&lt;p&gt;-preset must come first, as it overwritesother parameters.&lt;/p&gt;

&lt;p&gt;-m …………… compressionmethod (0=fast, 6=slowest)&lt;/p&gt;

&lt;p&gt;-segments …….. number ofsegments to use (1..4)&lt;/p&gt;

&lt;p&gt;-s ……… Inputsize (width x height) for YUV&lt;/p&gt;

&lt;p&gt;-sns …………. SpatialNoise Shaping (0:off, 100:max)&lt;/p&gt;

&lt;p&gt;-f …………… filterstrength (0=off..100)&lt;/p&gt;

&lt;p&gt;-sharpness ……. filtersharpness (0:most .. 7:least sharp)&lt;/p&gt;

&lt;p&gt;-strong ……………. use strong filterinstead of simple.&lt;/p&gt;

&lt;p&gt;-partition_limit . limitquality to fit the 512k limit on the first partition (0=no degradation …100=full)&lt;/p&gt;

&lt;p&gt;-pass ………… analysispass number (1..10)&lt;/p&gt;

&lt;p&gt;-partitions …… number ofpartitions to use (0..3)&lt;/p&gt;

&lt;p&gt;-crop .. crop picture with the given rectangle&lt;/p&gt;

&lt;p&gt;-resize …….. resizepicture (after any cropping)&lt;/p&gt;

&lt;p&gt;-map …………. print map ofextra info.&lt;/p&gt;

&lt;p&gt;-d ………. dump thecompressed output (PGM file).&lt;/p&gt;

&lt;p&gt;-short …………….. condense printedmessage&lt;/p&gt;

&lt;p&gt;-quiet …………….. don’t printanything.&lt;/p&gt;

&lt;p&gt;-version …………… print versionnumber and exit.&lt;/p&gt;

&lt;p&gt;-noasm …………….. disable allassembly optimizations.&lt;/p&gt;

&lt;p&gt;-v ………………… verbose, e.g.print encoding/decoding times&lt;/p&gt;

&lt;p&gt;Experimental Options:
-size ………… Target size(in bytes)&lt;/p&gt;

&lt;p&gt;-psnr ………. Target PSNR(in dB. typically: 42)&lt;/p&gt;

&lt;p&gt;-af ………….. adjustfilter strength (0=off, 1=on)&lt;/p&gt;

&lt;p&gt;-pre ………….pre-processing filter&lt;/p&gt;

&lt;p&gt;四、Webp文件转换成png/ppm/pgm文件&lt;/p&gt;

&lt;p&gt;通过dwebp命令可以将Webp文件转换成png/ppm/pgm文件&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;点击“开始”-&amp;gt;“运行”-&amp;gt;输入 cmd 后回车进入dos环境&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输入路径进入解压文件夹，以下是我安装的路径&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;C:\Documents andSettings\Administrator&amp;gt;e:&lt;/p&gt;

&lt;p&gt;E:&amp;gt;cd libwebp-0.1.3-windows-x86&lt;/p&gt;

&lt;p&gt;E:\libwebp-0.1.3-windows-x86&amp;gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;输入命令，将Webp转换成png/ppm/pgm&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Webp to png&lt;/p&gt;

&lt;p&gt;E:\libwebp-0.1.3-windows-x86&amp;gt;dwebpwebp1.webp –o png1.png&lt;/p&gt;

&lt;p&gt;Decoded webp1.webp. Dimensions: 2000 x1500. Now saving…&lt;/p&gt;

&lt;p&gt;Saved file png1.png&lt;/p&gt;

&lt;p&gt;转换成功，在E:\libwebp-0.1.3-windows-x86目录中会生成一个png1.png文件&lt;/p&gt;

&lt;p&gt;Webp to ppm
E:\libwebp-0.1.3-windows-x86&amp;gt;dwebpwebp1.webp –ppm –o ppm1.ppm&lt;/p&gt;

&lt;p&gt;Decoded webp1.webp. Dimensions: 2000 x1500. Now saving…&lt;/p&gt;

&lt;p&gt;Saved file ppm1.ppm&lt;/p&gt;

&lt;p&gt;转换成功，在E:\libwebp-0.1.3-windows-x86目录中会生成一个ppm1.ppm文件&lt;/p&gt;

&lt;p&gt;Webp to pgm&lt;/p&gt;

&lt;p&gt;E:\libwebp-0.1.3-windows-x86&amp;gt;dwebpwebp1.webp –ppm –o ppm1.pgm&lt;/p&gt;

&lt;p&gt;Decoded webp1.webp. Dimensions: 2000 x1500. Now saving…&lt;/p&gt;

&lt;p&gt;Saved file pgm1.pgm&lt;/p&gt;

&lt;p&gt;转换成功，在E:\libwebp-0.1.3-windows-x86目录中会生成一个pgm1.ppm文件&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;dwebp通过不同命令的选项，可以对图片进行一些设置。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;E:\libwebp-0.1.3-windows-x86&amp;gt;dwebp.exe –H（回车）&lt;/p&gt;

&lt;p&gt;Options:&lt;/p&gt;

&lt;p&gt;-ppm ……… save the raw RGB samples ascolor PPM&lt;/p&gt;

&lt;p&gt;-pgm ……… save the raw YUV samples asa grayscale PGM&lt;/p&gt;

&lt;p&gt;file with IMC4 layout.&lt;/p&gt;

&lt;p&gt;Other options are:&lt;/p&gt;

&lt;p&gt;-version …. print version number and exit.&lt;/p&gt;

&lt;p&gt;-nofancy ….. don’t use the fancy YUV420upscaler.&lt;/p&gt;

&lt;p&gt;-nofilter …. disable in-loop filtering.&lt;/p&gt;

&lt;p&gt;-mt ………. use multi-threading&lt;/p&gt;

&lt;p&gt;-crop … crop output with the given rectangle&lt;/p&gt;

&lt;p&gt;-scale ………. scalethe output (&lt;em&gt;after&lt;/em&gt; any cropping)&lt;/p&gt;

&lt;p&gt;-h    ……. this help message.&lt;/p&gt;

&lt;p&gt;-v    ……. verbose (e.g. print encoding/decoding times)&lt;/p&gt;

&lt;p&gt;-noasm ……. disable all assemblyoptimizations.&lt;/p&gt;

&lt;p&gt;五、在PC上查看webp文件&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装Google chrome浏览器
安装后打开chrome浏览器，然后将webp文件直接拖到浏览器中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装chrome内嵌框架插件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;地址：&lt;a href=&quot;http://code.google.com/intl/zh-CN/speed/webp/&quot;&gt;http://code.google.com/intl/zh-CN/speed/webp/&lt;/a&gt;
点击“接收并激活”开始在线安装&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Jul 2015 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>移动端上前端开发的一些问题与总结（3）</title>
        <link>http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-3/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-3/</guid>
        <description>&lt;p&gt;###关于ios系统中，webapp启动图片在不同设备上的适应性设置&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4687698/mulitple-apple-touch-startup-image-resolutions-for-ios-web-app-esp-for-ipad/10011893#10011893&quot;&gt;不同设备上的适应性设置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###关于ios系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格&lt;/p&gt;

&lt;p&gt;可以通过正则去掉&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;this.value = this.value.replace(/\u2006/g, '');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Cache开启和设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;browser.getSettings().setAppCacheEnabled(true);
browser.getSettings().setAppCachePath(&quot;/data/data/[com.packagename]/cache&quot;);
browser.getSettings().setAppCacheMaxSize(5*1024*1024); // 5MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###LocalStorage相关设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;browser.getSettings().setDatabaseEnabled(true);
browser.getSettings().setDomStorageEnabled(true);
String databasePath = browser.getContext().getDir(&quot;databases&quot;, Context.MODE_PRIVATE).getPath();
browser.getSettings().setDatabasePath(databasePath);//Android　webview的LocalStorage有个问题，关闭APP或者重启后，就清楚了，所以需要browser.getSettings().setDatabase相关的操作，把LocalStoarge存到DB中

myWebView.setWebChromeClient(new WebChromeClient(){
　　　@Override
　　　public void onExceededDatabaseQuota(String url, String databaseIdentifier, long currentQuota, long estimatedSize, long totalUsedQuota, WebStorage.QuotaUpdater quotaUpdater){
　　　　　　　quotaUpdater.updateQuota(estimatedSize * 2);
　　　}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###浏览器自带缩放按钮取消显示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;browser.getSettings().setBuiltInZoomControls(false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###几个比较好的实践&lt;/p&gt;

&lt;p&gt;使用localstorage缓存html&lt;/p&gt;

&lt;p&gt;使用lazyload，还要记得lazyload占位图虽然小，但是最好能提前加载到缓存&lt;/p&gt;

&lt;p&gt;延时加载执行js&lt;/p&gt;

&lt;p&gt;主要原因就在于Android Webview的onPageFinished事件，Android端一般是用这个事件来标识页面加载完成并显示的，也就是说在此之前，会一直loading，但是Android的OnPageFinished事件会在Javascript脚本执行完成之后才会触发。如果在页面中使用JQuery，会在处理完DOM对象，执行完$(document).ready(function() {});事件自会后才会渲染并显示页面。&lt;/p&gt;

&lt;p&gt;###移动浏览器篇&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UC浏览器 video标签脱离文档流&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;场景：标签的父元素(祖辈元素)设置transform样式后，标签会脱离文档流。&lt;/p&gt;

&lt;p&gt;测试环境：UC浏览器 8.7/8.6 + Android 2.3/4.0 。&lt;/p&gt;

&lt;p&gt;Demo：&lt;a href=&quot;http://maplejan.sinaapp.com/demo/uc_fixed.html&quot;&gt;http://t.cn/zj3xiyu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解决方案：不使用transform属性。translate用 top、 margin等属性替代。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UC浏览器 video标签总在最前场景：&lt;video&gt; 标签总是在最前（可以理解为video标签的z-index属性是Max）。&lt;/video&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;测试环境：UC浏览器 8.7/8.6 + Android 2.3/4.0 。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UC浏览器position:fixed 属性在UC浏览器的奇葩现象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;场景：设置了position: fixed 的元素会遮挡z-index值更高的同辈元素。&lt;/p&gt;

&lt;p&gt;在8.6的版本,这个情况直接出现。&lt;/p&gt;

&lt;p&gt;在8.7之后的版本,当同辈元素的height大于713这个「神奇」的数值时,才会被遮挡。&lt;/p&gt;

&lt;p&gt;测试环境：UC浏览器 8.8_beta/8.7/8.6 + Android 2.3/4.0 。&lt;/p&gt;

&lt;p&gt;Demo：&lt;a href=&quot;http://maplejan.sinaapp.com/demo/uc_fixed.html&quot;&gt;http://t.cn/zYLTSg6&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;QQ手机浏览器不支持HttpOnly&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;场景：带有HttpOnly属性的Cookie，在QQ手机浏览器版本从4.0开始失效。JavaScript可以直接读取设置了HttpOnly的Cookie值。&lt;/p&gt;

&lt;p&gt;测试环境：QQ手机浏览器 4.0/4.1/4.2 + Android 4.0 。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(MIUI原生浏览器)浏览器地址栏hash不改变&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;场景：location.hash 被赋值后，地址栏的地址不会改变。&lt;/p&gt;

&lt;p&gt;但实际上 location.href 已经更新了，通过JavaScript可以顺利获取到更新后的地址。&lt;/p&gt;

&lt;p&gt;虽然不影响正常访问，但用户无法将访问过程中改变hash后的地址存为书签。&lt;/p&gt;

&lt;p&gt;测试环境：MIUI 4.0&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(Chrome Mobile )fixed元素无法点击&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;场景：父元素设置position: fixed;&lt;/p&gt;

&lt;p&gt;子元素设置position: absolute;&lt;/p&gt;

&lt;p&gt;此时，如果父元素/子元素还设置了overflow: hidden 则出现“父元素遮挡该子元素“的bug。&lt;/p&gt;

&lt;p&gt;视觉(view)层并没有出现遮挡，只是无法触发绑定在该子元素上的事件。可理解为：「看到点不到」。&lt;/p&gt;

&lt;p&gt;补充： 页面往下滚动，触发position: fixed;的特性时，才会出现这个bug，在最顶不会出现。&lt;/p&gt;

&lt;p&gt;测试平台： 小米1S，Android4.0的Chrome18&lt;/p&gt;

&lt;p&gt;demo： &lt;a href=&quot;http://maplejan.sinaapp.com/demo/fixed_chromemobile.html&quot;&gt;http://maplejan.sinaapp.com/demo/fixed_chromemobile.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解决办法： 把父元素和子元素的overflow: hidden去掉。&lt;/p&gt;

&lt;p&gt;以上来源于 http://www.cnblogs.com/maplejan/archive/2013/04/26/3045928.html&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(微信浏览器)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为微信浏览器屏蔽了一部分链接图片，所以需要引导用户去打开新页面，可以用以下方式判断微信浏览器的ua&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;
function is_weixn(){
    var ua = navigator.userAgent.toLowerCase();
    if(ua.match(/MicroMessenger/i)==&quot;micromessenger&quot;) {
        return true;
    } else {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后端判断也很简单，比如php&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;function is_weixin(){ if ( strpos($_SERVER['HTTP_USER_AGENT'], 'MicroMessenger') !== false ) { return true; } return false;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###库的使用实践&lt;/p&gt;

&lt;p&gt;zepto.js&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://chaoskeh.com/blog/some-experience-of-using-zepto.html&quot;&gt;zepto的一篇使用注意点讲解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.youyo.name/archives/zepto-tap-click-through-research.html&quot;&gt;zepto的著名的tap“点透”bug&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html&quot;&gt;zepto源码注释&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###跨域问题&lt;/p&gt;

&lt;p&gt;手机浏览器也是浏览器，在ajax调用外部api的时候也存在跨域问题。当然利用phonegap打包后，由于协议不一样就不存在跨域问题了。 但页面通常是需要跟后端进行调试的。一般会报类似&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;XMLHttpRequest cannot load XXX
Origin null is not allowed by Access-Control-Allow-Origin.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;XMLHttpRequest cannot load http://. Request header field Content-Type is not allowed by Access-Control-Allow-Headers.&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候可以让后端加上两个http头&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;
Access-Control-Allow-Origin &quot;*&quot;
Access-Control-Allow-Headers &quot;Origin, X-Requested-With, Content-Type, Accept&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个头可以避免跨域问题，第二个头可以方便ajax请求设置content-type等配置项&lt;/p&gt;

&lt;p&gt;###调试篇&lt;/p&gt;

&lt;p&gt;手机抓包与配host&lt;/p&gt;

&lt;p&gt;在PC上，我们可以很方便地配host，但是手机上如何配host，这是一个问题。&lt;/p&gt;

&lt;p&gt;这里主要使用fiddler和远程代理，实现手机配host的操作，具体操作如下：&lt;/p&gt;

&lt;p&gt;首先，保证PC和移动设备在同一个局域网下；&lt;/p&gt;

&lt;p&gt;PC上开启fiddler，并在设置中勾选“allow remote computers to connect”&lt;/p&gt;

&lt;p&gt;首先，保证PC和移动设备在同一个局域网下；&lt;/p&gt;

&lt;p&gt;PC上开启fiddler，并在设置中勾选“allow remote computers to connect”&lt;/p&gt;

&lt;p&gt;手机上设置代理，代理IP为PC的IP地址，端口为8888（这是fiddler的默认端口）。通常手机上可以直接设置代理，如果没有，可以去下载一个叫ProxyDroid的APP来实现代理的设置。&lt;/p&gt;

&lt;p&gt;此时你会发现，用手机上网，走的其实是PC上的fiddler，所有的请求包都会在fiddler中列出来，配合willow使用，即可实现配host，甚至是反向代理的操作。&lt;/p&gt;

&lt;p&gt;###相关收藏&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/AlloyTeam/Mars&quot;&gt;腾讯移动Web前端知识库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一些非常重要的工具类网站&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ww1.sinaimg.cn/bmiddle/c2c57f68jw1e4fh7dmw12j20fi2w6qe1.jpg&quot;&gt;移动端手势表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ued.ctrip.com/webkitcss/index.html&quot;&gt;webkit独有的样式分析&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 19 May 2015 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>移动端上前端开发的一些问题与总结（2）</title>
        <link>http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-2/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-2/</guid>
        <description>&lt;p&gt;###使用特殊链接：&lt;/p&gt;

&lt;p&gt;如果你关闭自动识别后 ，又希望某些电话号码能够链接到 iPhone 的拨号功能 ，那么可以通过这样来声明电话链接 ,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&quot;tel:12345654321&quot;&amp;gt;打电话给我&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;sms:12345654321&quot;&amp;gt;发短信&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或用于单元格：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;td onclick=&quot;location.href='tel:122'&quot;&amp;gt;&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“文本”描述属性的特定文字样式，间距和自动滚屏。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;text-shadow: #00FFFC 10px 10px 5px;
text-transform: capitalize; 常量：capitalize/lowercase/none/uppercase
word-wrap: break-word; 常量：break-word/normal
-webkit-marquee: right large infinite normal 10s; 常量：direction(方向) increment(迭代次数) repetition(重复) style(样式) speed(速度);
-webkit-marquee-direction: ahead/auto/backwards/down/forwards/left/reverse/right/up
-webkit-marquee-incrementt: 1-n/infinite(无穷次)
-webkit-marquee-speed: fast/normal/slow
-webkit-marquee-style: alternate/none/scroll/slide
-webkit-text-fill-color: #ff6600; 常量：capitalize, lowercase, none, uppercase
-webkit-text-security: circle; 常量：circle/disc/none/square
-webkit-text-size-adjust: none; 常量:auto/none;
-webkit-text-stroke: 15px #fff;
-webkit-line-break: after-white-space; 常量：normal/after-white-space
-webkit-appearance: caps-lock-indicator;
-webkit-nbsp-mode: space; 常量： normal/space
-webkit-rtl-ordering: logical; 常量：visual/logical
-webkit-user-drag: element; 常量：element/auto/none
-webkit-user-modify: read- only; 常量：read-write-plaintext-only/read-write/read-only
-webkit-user-select: text; 常量：text/auto/none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“表格”描述的布局和设计性能表的具体内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;-webkit-border-horizontal-spacing: 2px;
-webkit-border-vertical-spacing: 2px;
-webkit-column-break-after: right; 常量：always/auto/avoid/left/right
-webkit-column-break-before: right; 常量：always/auto/avoid/left/right
–webkit-column-break-inside: logical; 常量：avoid/auto
-webkit-column-count: 3; //分栏
-webkit-column-rule: 1px solid #fff;
style:dashed,dotted,double,groove,hidden,inset,none,outset,ridge,solid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“用户界面”描述属性，涉及到用户界面元素在浏览器中，如滚动文字区，滚动条，等等。报告还描述属性，范围以外的网页内容，如光标的标注样式和显示当您按住触摸触摸 目标，如在iPhone上的链接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;-webkit-box-align: baseline,center,end,start,stretch 常量：baseline/center/end/start/stretch
-webkit-box-direction: normal;常量：normal/reverse
-webkit-box-flex: flex_valuet
-webkit-box-flex-group: group_number
-webkit-box-lines: multiple; 常量：multiple/single
-webkit-box-ordinal-group: group_number
-webkit-box-orient: block-axis; 常量：block-axis/horizontal/inline-axis/vertical/orientation
–webkit-box-pack: alignment; 常量：center/end/justify/start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;动画过渡 这是 Webkit 中最具创新力的特性：使用过渡函数定义动画。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;-webkit-animation: title infinite ease-in-out 3s;
animation 有这几个属性：
-webkit-animation-name： //属性名，就是我们定义的keyframes
-webkit-animation-duration：3s //持续时间
-webkit-animation-timing-function： //过渡类型：ease/ linear(线性) /ease-in(慢到快)/ease-out(快到慢) /ease-in-out(慢到快再到慢) /cubic-bezier
-webkit-animation-delay：10ms //动画延迟(默认0)
-webkit-animation-iteration-count： //循环次数(默认1)，infinite 为无限
-webkit-animation-direction： //动画方式：normal(默认 正向播放)； alternate(交替方向，第偶数次正向播放，第奇数次反向播放)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些同样是可以简写的。但真正让我觉的很爽的是keyframes，它能定义一个动画的转变过程供调用，过程为0%到100%或from(0%)到to(100%)。简单点说，只要你有想法，你想让元素在这个过程中以什么样的方式改变都是很简单的。&lt;/p&gt;

&lt;p&gt;-webkit-transform: 类型（缩放scale/旋转rotate/倾斜skew/位移translate）
scale(num,num) 放大倍率。scaleX 和 scaleY(3)，可以简写为：scale(* , &lt;em&gt;)
rotate(&lt;/em&gt;deg) 转动角度。rotateX 和 rotateY，可以简写为：rotate(* , &lt;em&gt;)
Skew(&lt;/em&gt;deg) 倾斜角度。skewX 和skewY，可简写为：skew(* , &lt;em&gt;)
translate(&lt;/em&gt;,&lt;em&gt;) 坐标移动。translateX 和translateY，可简写为：translate(&lt;/em&gt; , *)。
___&lt;/p&gt;

&lt;p&gt;###锁定 viewport&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;ontouchmove=&quot;event.preventDefault()&quot; //锁定viewport，任何屏幕操作不移动用户界面（弹出键盘除外）。
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;###被点击元素的外观变化，可以使用样式来设定：&lt;/p&gt;

&lt;p&gt;-webkit-tap-highlight-color: 颜色&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;###侦测iPhone/iPod&lt;/p&gt;

&lt;p&gt;开发特定设备的移动网站，首先要做的就是设备侦测了。下面是使用Javascript侦测iPhone/iPod的UA，然后转向到专属的URL。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i))) {
	if (document.cookie.indexOf(&quot;iphone_redirect=false&quot;) == -1) {
		window.location = &quot;http://m.example.com&quot;;
		}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;###阻止旋转屏幕时自动调整字体大小&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 {-webkit-text-size-adjust:none;}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;###模拟:hover伪类&lt;/p&gt;

&lt;p&gt;因为iPhone并没有鼠标指针，所以没有hover事件。那么CSS :hover伪类就没用了。但是iPhone有Touch事件，onTouchStart 类似 onMouseOver，onTouchEnd 类似 onMouseOut。所以我们可以用它来模拟hover。使用Javascript：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var myLinks = document.getElementsByTagName('a');
	for(var i = 0; i &amp;lt; myLinks.length; i++){
		myLinks[i].addEventListener('touchstart', function(){
			this.className = 'hover';
			}, false);
		myLinks[i].addEventListener('touchend', function(){
			this.className = '';}, false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;###flexbox布局模板&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jsbin.com/ibuwol/2/edit&quot;&gt;flex模板&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3cplus.com/blog/666.html&quot;&gt;深入了解flex布局&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;###测试是否支持svg图片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;document.implementation.hasFeature(&quot;http:// www.w3.org/TR/SVG11/feature#Image&quot;, &quot;1.1&quot;);

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;###消除transition闪屏&lt;/p&gt;

&lt;p&gt;两个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;
-webkit-transform-style: preserve-3d;
/*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/
-webkit-backface-visibility:?hidden;
/*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/

&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;###消除ie10里面的那个叉号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;Pseudo-elements

input:-ms-clear{display:none;}

&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;###ie10的特殊鼠标事件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.mansonchor.com/blog/blog_detail_73.html&quot;&gt;IE10 事件监听&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;###不让android识别邮箱&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;###禁止ios弹出各种操作窗口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;
-webkit-touch-callout:none
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;###禁止用户选中文字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;
-webkit-user-select:none
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;p&gt;###拿到滚动条&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;
window.scrollY
window.scrollX
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 12 May 2015 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>移动端上前端开发的一些问题与总结（1）</title>
        <link>http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-1/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93-1/</guid>
        <description>&lt;p&gt;在工作中遇到的一些问题和fix方法，做一个汇总：&lt;/p&gt;

&lt;p&gt;###样式表:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;startup.png&quot; /&amp;gt; // 设置开始页面图片
&amp;lt;link rel=&quot;apple-touch-icon&quot; href=&quot;iphon_tetris_icon.png&quot;/&amp;gt; // 在设置书签的时候可以显示好看的图标
&amp;lt;link rel=&quot;stylesheet&quot; media=&quot;all and (orientation:portrait)&quot; href=&quot;portrait.css&quot;&amp;gt;    // 肖像模式样式
&amp;lt;link rel=&quot;stylesheet&quot; media=&quot;all and (orientation:landscape)&quot;href=&quot;landscape.css&quot;&amp;gt;   // 风景模式样式

//竖屏时使用的样式
&amp;lt;style media=&quot;all and (orientation:portrait)&quot; type=&quot;text/css&quot;&amp;gt;
#landscape { display: none; }
&amp;lt;/style&amp;gt;

//横屏时使用的样式
&amp;lt;style media=&quot;all and (orientation:landscape)&quot; type=&quot;text/css&quot;&amp;gt;#portrait { display: none; }&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###meta标签:&lt;/p&gt;

&lt;p&gt;这些meta标签在开发webapp时起到非常重要的作用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot; /&amp;gt;
&amp;lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot; /&amp;gt;
&amp;lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot; /&amp;gt;
&amp;lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个meta标签表示：强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览；&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;p&gt;width - viewport的宽度&lt;/p&gt;

&lt;p&gt;height - viewport的高度&lt;/p&gt;

&lt;p&gt;initial-scale - 初始的缩放比例&lt;/p&gt;

&lt;p&gt;minimum-scale - 允许用户缩放到的最小比例&lt;/p&gt;

&lt;p&gt;maximum-scale - 允许用户缩放到的最大比例&lt;/p&gt;

&lt;p&gt;user-scalable - 用户是否可以手动缩放&lt;/p&gt;

&lt;p&gt;第二个meta标签是iphone设备中的safari私有meta标签，它表示：允许全屏模式浏览；&lt;/p&gt;

&lt;p&gt;第三个meta标签也是iphone的私有标签，它指定的iphone中safari顶端的状态条的样式；&lt;/p&gt;

&lt;p&gt;第四个meta标签表示：告诉设备忽略将页面中的数字识别为电话号码&lt;/p&gt;

&lt;p&gt;###页面描述(iOS)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;http://www.xxx.com/App_icon_114.png&quot; /&amp;gt;
&amp;lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;72x72&quot; href=&quot;http://www.xxx.com/App_icon_72.png&quot; /&amp;gt;
&amp;lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;http://www.xxx.com/App_icon_114.png&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个属性是当用户把连接保存到手机桌面时使用的图标，如果不设置，则会用网页的截图。有了这，就可以让你的网页像APP一样存在手机里了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/img/startup.png&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个是APP启动画面图片，用途和上面的类似，如果不设置，启动画面就是白屏，图片像素就是手机全屏的像素&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个描述是表示打开的web app的最上面的时间、信号栏是黑色的，当然也可以设置其它参数，详细参数说明在：Supported Meta Tags&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&amp;gt;
&amp;lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这2个描述也很有用的，如果没有它，你的web app会用safari浏览器打开，有了它，就会用独立进程的无地址栏的打开，完全可以和普通的APP比拟了&lt;/p&gt;

&lt;p&gt;下面还有个不错的css，是用来区分视网膜屏幕的，这样你可以在iphone这样的手机里载入2x的图片，就不会模糊了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;
@media only screen and (-webkit-min-device-pixel-ratio:1.5),only screen and (min--moz-device-pixel-ratio:1.5),only screen and (min-device-pixel-ratio:1.5),only screen and (min-resolution:200dpi)
{
#logo{background-image: url(logo@2x.png);}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###关于点击和click事件&lt;/p&gt;

&lt;p&gt;对于a标记的点击导航，默认是在onclick事件中处理的。而移动客户端对onclick的响应相比PC浏览器有着明显的几百毫秒延迟。&lt;/p&gt;

&lt;p&gt;在移动浏览器中对触摸事件的响应顺序应当是：&lt;/p&gt;

&lt;p&gt;ontouchstart -&amp;gt; ontouchmove -&amp;gt; ontouchend -&amp;gt; onclick
因此，如果确实要加快对点击事件的响应，就应当绑定ontouchend事件。&lt;/p&gt;

&lt;p&gt;使用click会出现绑定点击区域闪一下的情况，解决：给该元素一个样式如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;-webkit-tap-highlight-color: rgba(0,0,0,0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不使用click，也不能简单的用touchstart或touchend替代，需要用touchstart的模拟一个click事件，并且不能发生touchmove事件，或者用zepto中的tap（轻击）事件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;body{-webkit-overflow-scrolling: touch;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用iphone或ipad浏览很长的网页滚动时的滑动效果很不错吧？不过如果是一个div，然后设置height:200px;overflow:auto;的话，可以滚动但是完全没有那滑动效果，很郁闷吧？ 我看到很多网站为了实现这一效果，用了第三方类库，最常用的是iscroll（包括新浪手机页，百度等） 我一开始也使用，不过自从用了-webkit-overflow-scrolling:touch;样式后，就完全可以抛弃第三方类库了，把它加在body{}区域，所有的overflow需要滚动的都可以生效了。&lt;/p&gt;

&lt;p&gt;###手机浏览器常用手势动作监听封装(配合zepto,from mansonchor)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wo.poco.cn/manson/post/id/268780&quot; alt=&quot;手机浏览器常用手势动作监听封装&quot;&gt;手机浏览器常用手势动作监听封装&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###事件：(参考：引用了指尖上的js系列，在此向作者表示感谢)
&lt;a href=&quot;http://www.cnblogs.com/pifoo/archive/2011/05/23/webkit-touch-event-1.html&quot;&gt;对于Touch的处理&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/pifoo/archive/2011/05/22/webkit-touch-event-2.html&quot;&gt;处理简单手势&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/pifoo/archive/2011/05/22/webkit-touch-event-3.html&quot;&gt;处理复杂手势&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###手势事件&lt;/p&gt;

&lt;p&gt;touchstart //当手指接触屏幕时触发&lt;/p&gt;

&lt;p&gt;touchmove //当已经接触屏幕的手指开始移动后触发&lt;/p&gt;

&lt;p&gt;touchend //当手指离开屏幕时触发&lt;/p&gt;

&lt;p&gt;touchcancel&lt;/p&gt;

&lt;p&gt;###触摸事件&lt;/p&gt;

&lt;p&gt;gesturestart //当两个手指接触屏幕时触发&lt;/p&gt;

&lt;p&gt;gesturechange //当两个手指接触屏幕后开始移动时触发&lt;/p&gt;

&lt;p&gt;gestureend&lt;/p&gt;

&lt;p&gt;###屏幕旋转事件&lt;/p&gt;

&lt;p&gt;onorientationchange //检测触摸屏幕的手指何时改变方向&lt;/p&gt;

&lt;p&gt;orientationchange //touch事件支持的相关属性&lt;/p&gt;

&lt;p&gt;touches&lt;/p&gt;

&lt;p&gt;targetTouches&lt;/p&gt;

&lt;p&gt;changedTouches&lt;/p&gt;

&lt;p&gt;clientX　　　　// X coordinate of touch relative to the viewport (excludes scroll offset)&lt;/p&gt;

&lt;p&gt;clientY　　　　// Y coordinate of touch relative to the viewport (excludes scroll offset)&lt;/p&gt;

&lt;p&gt;screenX　　　 // Relative to the screen&lt;/p&gt;

&lt;p&gt;screenY 　　 // Relative to the screen&lt;/p&gt;

&lt;p&gt;pageX　　 　　// Relative to the full page (includes scrolling)&lt;/p&gt;

&lt;p&gt;pageY　　　　 // Relative to the full page (includes scrolling)&lt;/p&gt;

&lt;p&gt;target　　　　 // Node the touch event originated from&lt;/p&gt;

&lt;p&gt;identifier　　 // An identifying number, unique to each touch event&lt;/p&gt;

&lt;p&gt;屏幕旋转事件：onorientationchange 添加屏幕旋转事件侦听，可随时发现屏幕旋转状态（左旋、右旋还是没旋）&lt;/p&gt;

&lt;p&gt;###判断屏幕是否旋转&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function orientationChange() { 
	switch (window.orientation) {
		case 0: alert(&quot;肖像模式 0,screen-width: &quot; + screen.width + &quot;;screen-height:&quot; + screen.height);
		break;
		case -90: alert(&quot;左旋 -90,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height);
		break;
		case 90: alert(&quot;右旋 90,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height); 
		break;
		case 180: alert(&quot;风景模式 180,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height);
		break; 
	}; 
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###添加事件监听&lt;/p&gt;

&lt;p&gt;addEventListener(‘load’, function(){
    orientationChange();
    window.onorientationchange = orientationChange;
});&lt;/p&gt;

&lt;p&gt;###双手指滑动事件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// 双手指滑动事件

addEventListener('load',function(){ window.onmousewheel = twoFingerScroll;},
    false // 兼容各浏览器，表示在冒泡阶段调用事件处理程序 (true 捕获阶段)
);

function twoFingerScroll(ev) {
    var delta =ev.wheelDelta/120; //对 delta 值进行判断(比如正负) ，而后执行相应操作
    return true;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;localstorage&quot;&gt;localStorage:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var v = localStorage.getItem('n') ? localStorage.getItem('n') : &quot;&quot;; // 如果名称是  n 的数据存在 ，则将其读出 ，赋予变量  v  。
localStorage.setItem('n', v); // 写入名称为 n、值为  v  的数据
localStorage.removeItem('n'); // 删除名称为  n  的数据
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 24 Apr 2015 00:00:00 +0800</pubDate>
      </item>
    
  </channel>
</rss>
